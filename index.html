<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>SuperMan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="SuperMan">
<meta property="og:url" content="https://github.com/SuperManZTF/ThreeDimensional/index.html">
<meta property="og:site_name" content="SuperMan">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="SuperMan">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/ThreeDimensional/atom.xml" title="SuperMan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/ThreeDimensional/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/ThreeDimensional/" id="logo">SuperMan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/ThreeDimensional/">Home</a>
        
          <a class="main-nav-link" href="/ThreeDimensional/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/ThreeDimensional/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/SuperManZTF/ThreeDimensional"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-1-Cesium-ZFighting" class="article article-type-post" itemscope
   itemprop="blogPost">
   <div class="article-meta">
      <a href="/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/" class="article-date">
  <time datetime="2021-08-25T06:09:28.702Z" itemprop="datePublished">2021-08-25</time>
</a>
      
   </div>
   <div class="article-inner">
      
      
      <header class="article-header">
         
  
    <h1 itemprop="name">
      <a class="article-title" href="/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/">Cesium-Z-Fighting 深度冲突问题</a>
    </h1>
  

      </header>
      
      <!-- <div class="article-entry" itemprop="articleBody">
         
         <p>&ensp; &ensp; &ensp; 在Cesium引擎中深度冲突（Z-Fighting）是绕不开的。之所以会产生深度冲突，是因为两个表面过于接近，深度缓冲区有限的精度已经不能区分哪个在前哪个在后。解决深度冲突问题普遍的方法有“对数深度”和“多边形偏移”，在Cesium当中解决该问题有两种方式“多视锥体”和“多视锥体+对数深度”。<br>&ensp; &ensp; &ensp; GIS-地球渲染的是行星级别的比例尺，用米度量的分辨率会出现深度冲突和抖动的现象。这里作者使用的是Cesium-1.71版本。关于深度冲突本质上是数值的精度问题，Cesium引擎中处理精度问题还有两种方式RTC和RTE，请结合《Cesium-Precision 精度问题》一文来理解。</p>
<h2 id="1-正常情况下Shader中深度如何计算？"><a href="#1-正常情况下Shader中深度如何计算？" class="headerlink" title="1. 正常情况下Shader中深度如何计算？"></a>1. 正常情况下Shader中深度如何计算？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// vertex shader</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    vec3 transformed = vec3( position );</span><br><span class="line">    vec4 mvPosition = vec4( transformed, 1.0 );</span><br><span class="line">    mvPosition = modelViewMatrix * mvPosition;</span><br><span class="line">    gl_Position = projectionMatrix * mvPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// fragment shader</span><br><span class="line">void <span class="function"><span class="title">mian</span></span>()&#123;</span><br><span class="line">    gl_FragColor = vec4( 1.0,0.0,0.0,1.0 ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在顶点着色器中做了两个矩阵变换（本质上是三个MV乘起来了）：modelViewMatrix和projectionMatrix，将顶点从局部坐标系转到世界坐标系转到相机坐标系转到投影坐标系，这里的projectionMatrix矩阵是根据相机的视锥体构建的（构建过程参考ThreeJS-Camera），经过矩阵计算gl_Position是被转换到投影剪裁空间（具体参考冯乐乐《Unity Shader入门精要》第四章），此处只说结论：经过矩阵变换最终写入深度缓冲区的深度值是“片元距离相机视锥体近截面的距离”（这个结论如果理解不了就先暂时接受并大胆认可它）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// program</span><br><span class="line">gl.getExtension(<span class="string">&#x27;EXT_frag_depth&#x27;</span>);</span><br><span class="line">// fragment shader</span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0); </span><br><span class="line">  gl_FragDepthEXT = 0.5; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在WebGL shader中如果想在片元着色器中修改片元的深度需要用到WebGL扩展EXT_frag_depth，使用gl_FragDepthEXT可以修改片元的深度值，后边使用对数深度修改片元深度的时候会用到这个扩展，在Cesium中这个扩展及其重要，例如贴地线/贴地面等都会涉及到深度值的修改。</p>
<h2 id="2-多边形偏移"><a href="#2-多边形偏移" class="headerlink" title="2. 多边形偏移"></a>2. 多边形偏移</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// program</span><br><span class="line">gl.enable(gl.POLYGON_OFFSET_FILL);// 启用多边形偏移</span><br><span class="line">gl.polygonOffset(1.0, 1.0);</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 开启多边形偏移之后，设置多边形偏移参数：gl.polygonOffset(factor, units), 指定加到每个顶点z值上的偏移量，偏移量按m<em>factor+r</em>units来计算，m表示顶点所在表面相对于相机视线的角度，r表示硬件能够区分两个z值之差的最小值。这种处理深度冲突的方式在深度值精度够用的情况下是可以的，但是解决不了精度不够用的情况。</p>
<h2 id="3-多视锥体渲染"><a href="#3-多视锥体渲染" class="headerlink" title="3. 多视锥体渲染"></a>3. 多视锥体渲染</h2><p>&ensp; &ensp; &ensp; 多视锥体渲染的关键是根据frameState.commandList来计算视锥体的远近截面和视锥体数量，并将frameState.commandList分类存放到view.frustumCommandsList。在Cesium-view中View.prototype.createPotentiallyVisibleSet是关键方法。<br>&ensp; &ensp; &ensp; view类中的frustumCommandsList在scene.executeCommands中会遍历并执行其中的DrawCommand，这个数组中根据视锥体数量保存着FrustumCommands（其中根据Pass保存渲染不同类型的对象的DrawCommand）。相信阅读这篇博客的同仁是熟悉Cesium渲染流程的，此处不在赘述，如果不理解请在scene.executeCommands函数中自行断点。由于该方法涉及的内容很多，这里我先贴出代码注释，接下来会把涉及到的每个点进行讲解，最后再整体总结一遍流程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">View.prototype.createPotentiallyVisibleSet = <span class="keyword">function</span> (scene) &#123;</span><br><span class="line">  var frameState = scene.frameState;</span><br><span class="line">  var camera = frameState.camera;</span><br><span class="line">  var direction = camera.directionWC;// 世界坐标下的相机方向</span><br><span class="line">  var position = camera.positionWC;// 世界坐标下的相机位置</span><br><span class="line"></span><br><span class="line">  var computeList = scene._computeCommandList;// 计算指令</span><br><span class="line">  var overlayList = scene._overlayCommandList;// 覆盖指令</span><br><span class="line">  var commandList = frameState.commandList;// 与视锥体有关的指令</span><br><span class="line"></span><br><span class="line">  // 调试“多视锥体”</span><br><span class="line">  <span class="keyword">if</span> (scene.debugShowFrustums) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 视锥体指令集合 索引置零</span><br><span class="line">  var frustumCommandsList = this.frustumCommandsList;</span><br><span class="line">  var numberOfFrustums = frustumCommandsList.length;</span><br><span class="line">  var numberOfPasses = Pass.NUMBER_OF_PASSES;</span><br><span class="line">  <span class="keyword">for</span> (var n = 0; n &lt; numberOfFrustums; ++n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var p = 0; p &lt; numberOfPasses; ++p) &#123;</span><br><span class="line">      frustumCommandsList[n].indices[p] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 通用计算指令清除</span><br><span class="line">  computeList.length = 0;</span><br><span class="line">  // 覆盖指令清除</span><br><span class="line">  overlayList.length = 0;</span><br><span class="line"></span><br><span class="line">  var commandExtents = this._commandExtents;</span><br><span class="line">  var commandExtentCapacity = commandExtents.length;</span><br><span class="line">  var commandExtentCount = 0;</span><br><span class="line"></span><br><span class="line">  // JS 数值最大值 加减 1</span><br><span class="line">  var near = +Number.MAX_VALUE;</span><br><span class="line">  var far = -Number.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  var shadowsEnabled = frameState.shadowState.shadowsEnabled;</span><br><span class="line">  var shadowNear = +Number.MAX_VALUE;</span><br><span class="line">  var shadowFar = -Number.MAX_VALUE;</span><br><span class="line">  var shadowClosestObjectSize = Number.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  // 判断地球是否遮挡物体</span><br><span class="line">  var occluder = frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;</span><br><span class="line">  // 相机视锥体</span><br><span class="line">  var cullingVolume = frameState.cullingVolume;</span><br><span class="line"></span><br><span class="line">  // get user culling volume minus the far plane.除掉视锥体远平面</span><br><span class="line">  var planes = scratchCullingVolume.planes;</span><br><span class="line">  <span class="keyword">for</span> (var k = 0; k &lt; 5; ++k) &#123;</span><br><span class="line">    planes[k] = cullingVolume.planes[k];</span><br><span class="line">  &#125;</span><br><span class="line">  cullingVolume = scratchCullingVolume;</span><br><span class="line"></span><br><span class="line">  var length = commandList.length;</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">    var <span class="built_in">command</span> = commandList[i];</span><br><span class="line">    var pass = command.pass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass === Pass.COMPUTE) &#123;// 计算指令</span><br><span class="line">      computeList.push(<span class="built_in">command</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pass === Pass.OVERLAY) &#123;// 覆盖指令</span><br><span class="line">      overlayList.push(<span class="built_in">command</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      var commandNear;</span><br><span class="line">      var commandFar;</span><br><span class="line"></span><br><span class="line">      var boundingVolume = command.boundingVolume;// 渲染指令包围盒</span><br><span class="line">      <span class="keyword">if</span> (defined(boundingVolume)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!scene.isVisible(<span class="built_in">command</span>, cullingVolume, occluder)) &#123;// 判断显示隐藏</span><br><span class="line">          <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 包围球的圆心和相机位置的射线 向 相机方向 投影 dot算出 一段距离 -&gt; 加减 半径</span><br><span class="line">        var nearFarInterval = boundingVolume.computePlaneDistances(</span><br><span class="line">          position,</span><br><span class="line">          direction,</span><br><span class="line">          scratchNearFarInterval</span><br><span class="line">        );</span><br><span class="line">        commandNear = nearFarInterval.start;</span><br><span class="line">        commandFar = nearFarInterval.stop;</span><br><span class="line"></span><br><span class="line">        // console.log(<span class="string">&#x27;near: &#x27;</span> + commandNear + <span class="string">&#x27;far: &#x27;</span> + commandFar);</span><br><span class="line"></span><br><span class="line">        near = Math.min(near, commandNear);// 根据JS最大小值限制</span><br><span class="line">        far = Math.max(far, commandFar);</span><br><span class="line"></span><br><span class="line">        // Compute a tight near and far plane <span class="keyword">for</span> commands that receive shadows. This helps compute</span><br><span class="line">        // good splits <span class="keyword">for</span> cascaded shadow maps. Ignore commands that exceed the maximum distance.</span><br><span class="line">        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes</span><br><span class="line">        // throw off the near/far fitting <span class="keyword">for</span> the shadow map. Only update <span class="keyword">for</span> globe tiles that the</span><br><span class="line">        // camera is not inside.</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          shadowsEnabled &amp;&amp;</span><br><span class="line">          command.receiveShadows &amp;&amp;</span><br><span class="line">          commandNear &lt; ShadowMap.MAXIMUM_DISTANCE &amp;&amp;</span><br><span class="line">          !(pass === Pass.GLOBE &amp;&amp; commandNear &lt; -100.0 &amp;&amp; commandFar &gt; 100.0)</span><br><span class="line">        ) &#123;</span><br><span class="line">          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.</span><br><span class="line">          var size = commandFar - commandNear;</span><br><span class="line">          <span class="keyword">if</span> (pass !== Pass.GLOBE &amp;&amp; commandNear &lt; 100.0) &#123;</span><br><span class="line">            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);</span><br><span class="line">          &#125;</span><br><span class="line">          shadowNear = Math.min(shadowNear, commandNear);</span><br><span class="line">          shadowFar = Math.max(shadowFar, commandFar);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">command</span> instanceof ClearCommand) &#123;</span><br><span class="line">        // Clear commands dont need a bounding volume - just add the clear to all frustums.</span><br><span class="line">        commandNear = camera.frustum.near;</span><br><span class="line">        commandFar = camera.frustum.far;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // If <span class="built_in">command</span> has no bounding volume we need to use the camera s</span><br><span class="line">        // worst-case near and far planes to avoid clipping something important.</span><br><span class="line">        commandNear = camera.frustum.near;</span><br><span class="line">        commandFar = camera.frustum.far;</span><br><span class="line">        near = Math.min(near, commandNear);</span><br><span class="line">        far = Math.max(far, commandFar);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var extent = commandExtents[commandExtentCount];</span><br><span class="line">      <span class="keyword">if</span> (!defined(extent)) &#123;</span><br><span class="line">        extent = commandExtents[commandExtentCount] = new CommandExtent();</span><br><span class="line">      &#125;</span><br><span class="line">      extent.command = <span class="built_in">command</span>;</span><br><span class="line">      extent.near = commandNear;</span><br><span class="line">      extent.far = commandFar;</span><br><span class="line">      commandExtentCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shadowsEnabled) &#123;</span><br><span class="line">    shadowNear = Math.min(</span><br><span class="line">      Math.max(shadowNear, camera.frustum.near),</span><br><span class="line">      camera.frustum.far</span><br><span class="line">    );</span><br><span class="line">    shadowFar = Math.max(Math.min(shadowFar, camera.frustum.far), shadowNear);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Use the computed near and far <span class="keyword">for</span> shadows</span><br><span class="line">  <span class="keyword">if</span> (shadowsEnabled) &#123;</span><br><span class="line">    frameState.shadowState.nearPlane = shadowNear;</span><br><span class="line">    frameState.shadowState.farPlane = shadowFar;</span><br><span class="line">    frameState.shadowState.closestObjectSize = shadowClosestObjectSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateFrustums(this, scene, near, far);</span><br><span class="line"></span><br><span class="line">  var c;</span><br><span class="line">  var ce;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (c = 0; c &lt; commandExtentCount; c++) &#123;</span><br><span class="line">    ce = commandExtents[c];</span><br><span class="line">    insertIntoBin(this, scene, ce.command, ce.near, ce.far);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Dereference old commands</span><br><span class="line">  <span class="keyword">if</span> (commandExtentCount &lt; commandExtentCapacity) &#123;</span><br><span class="line">    <span class="keyword">for</span> (c = commandExtentCount; c &lt; commandExtentCapacity; c++) &#123;</span><br><span class="line">      ce = commandExtents[c];</span><br><span class="line">      <span class="keyword">if</span> (!defined(ce.command)) &#123;</span><br><span class="line">        // If the <span class="built_in">command</span> is undefined, its assumed that all</span><br><span class="line">        // subsequent commmands were <span class="built_in">set</span> to undefined as well,</span><br><span class="line">        // so no need to loop over them all</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ce.command = undefined;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var numFrustums = frustumCommandsList.length;</span><br><span class="line">  var frustumSplits = frameState.frustumSplits;</span><br><span class="line">  frustumSplits.length = numFrustums + 1;</span><br><span class="line">  <span class="keyword">for</span> (var j = 0; j &lt; numFrustums; ++j) &#123;</span><br><span class="line">    frustumSplits[j] = frustumCommandsList[j].near;</span><br><span class="line">    <span class="keyword">if</span> (j === numFrustums - 1) &#123;</span><br><span class="line">      frustumSplits[j + 1] = frustumCommandsList[j].far;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 重要的事情说三遍：这个方法很重要X3！<br>&ensp; &ensp; &ensp; 首先提前说明两个事情：frameState中的occluder和cullingVolume是干什么的？<br>&ensp; &ensp; &ensp; Occluder: 由位置和半径来定义一个球Sphere再结合相机的位置，来计算一个点或者一个包围球等是否被球Sphere遮挡（具体代码详见Cesium-Occluder类），结果有三种。这里在frameState上的occluder是使用地球和相机共同定义的，用于判断某个物体（使用其包围球计算）与地球的遮挡情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var Visibility = &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Represents that no part of an object is visible.</span><br><span class="line">   */</span><br><span class="line">  NONE: -1,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that part, but not all, of an object is visible</span><br><span class="line">   */</span><br><span class="line">  PARTIAL: 0,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is visible <span class="keyword">in</span> its entirety.</span><br><span class="line">   */</span><br><span class="line">  FULL: 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; CullingVolume：由若干个面定义的体用于计算剔除。每个面是一个Cartesian4对象，xyz代表平面法线，w代表平面与原点的距离，这与ThreeJS当中Plane的定义是一样的。这里在frameState上的cullingVolume是由相机计算而来的（是视锥体，但用法有故事）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The culling volume defined by planes. </span><br><span class="line"> *</span><br><span class="line"> * @<span class="built_in">alias</span> CullingVolume</span><br><span class="line"> * @constructor</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Cartesian4[]&#125; [planes] An array of clipping planes.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> CullingVolume(planes) &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Each plane is represented by a Cartesian4 object, <span class="built_in">where</span> the x, y, and z components</span><br><span class="line">   * define the unit vector normal to the plane, and the w component is the distance of the</span><br><span class="line">   * plane from the origin.</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Cartesian4[]&#125;</span><br><span class="line">   * @default []</span><br><span class="line">   */</span><br><span class="line">  this.planes = defaultValue(planes, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在DrawCommand中会有boundingVolume（包围球），scene.isVisible(command, cullingVolume, occluder)会计算判断一个DrawCommand是否可以在此帧渲染，这个判断至关重要！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scene.prototype.isVisible = <span class="keyword">function</span> (<span class="built_in">command</span>, cullingVolume, occluder) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    defined(<span class="built_in">command</span>) &amp;&amp;</span><br><span class="line">    (!defined(command.boundingVolume) || !command.cull ||</span><br><span class="line">      (cullingVolume.computeVisibility(command.boundingVolume) !==</span><br><span class="line">        Intersect.OUTSIDE &amp;&amp;</span><br><span class="line">        (!defined(occluder) ||</span><br><span class="line">          !command.occlude ||</span><br><span class="line">          !command.boundingVolume.isOccluded(occluder))))</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在上面代码中有两个计算函数：cullingVolume.computeVisibility和command.boundingVolume.isOccluded，在上面已经讲过cullingVolume和occluder的定义以及用途，此处不再赘述。此处得出一个重要结论：(!scene.isVisible(command, cullingVolume, occluder))为false，DrawCommand就是可以渲染的! 这里需要说明一下，cullingVolume.computeVisibility的计算结果有三种情况，如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var Intersect = &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is not contained within the frustum.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  OUTSIDE: -1,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object intersects one of the frustum s planes.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  INTERSECTING: 0,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is fully within the frustum.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  INSIDE: 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 如果一个DrawCommand是可以渲染的，接下来它就将参与计算相机的远近截面。这个地方的远近截面是所有可渲染的DrawCommand计算出的commandNear和commandFar的累计，累计规则：选出near的最小值和far的最大值。每个DrawCommand是如何计算出commandNear和commandFar呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BoundingSphere.computePlaneDistances = <span class="keyword">function</span> (</span><br><span class="line">  sphere,</span><br><span class="line">  position,</span><br><span class="line">  direction,</span><br><span class="line">  result</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!defined(result)) &#123;</span><br><span class="line">    result = new Interval();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var toCenter = Cartesian3.subtract(</span><br><span class="line">    sphere.center,</span><br><span class="line">    position,</span><br><span class="line">    scratchCartesian3</span><br><span class="line">  );</span><br><span class="line">  var mag = Cartesian3.dot(direction, toCenter);</span><br><span class="line"></span><br><span class="line">  result.start = mag - sphere.radius;</span><br><span class="line">  result.stop = mag + sphere.radius;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 上面函数中有四个参数：sphere（DrawCommand包围球）position（相机世界坐标位置）direction（相机世界坐标朝向）result（返回结果），注意这里调用这个方法计算传入的参数含义只是在当前计算环境下传参意义，如果此函数用作他用另当别论。渲染指令的包围球由center和radius定义，即包围球位置和半径；通过center和position构建一条向量N，N向direction做投影P（点积计算），投影P在direction方向上的投影“覆盖”距离加上radius就是commandFar，减去radius就是commandNear，如图示。<br><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/nearfar.png" alt="计算Command的near/far"><br>&ensp; &ensp; &ensp; 已经计算出了每个可渲染的DrawCommand以及累计得到了near和far，接下来就要确定视锥体的数量updateFrustums；由下面代码可以看出，根据near和far计算视锥体数量就靠一个公式：numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio))，这个公式将其输入到Graph中看一下函数图像，视锥体数量分为三个：1到1000米、1000到100万、100万到100亿之间，如图示。有了视锥体数量之后就可以创建FrustumCommands并放到view.frustumCommandsList中，上文已经说过了，view.frustumCommandsList在scene.executeCommands中遍历执行。<br><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/numFrust.jpg" alt="计算视锥体数量"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateFrustums(view, scene, near, far) &#123;</span><br><span class="line">  var frameState = scene.frameState;</span><br><span class="line">  var camera = frameState.camera;</span><br><span class="line">  var farToNearRatio = frameState.useLogDepth</span><br><span class="line">    ? scene.logarithmicDepthFarToNearRatio</span><br><span class="line">    : scene.farToNearRatio;</span><br><span class="line">  var is2D = scene.mode === SceneMode.SCENE2D;</span><br><span class="line">  var nearToFarDistance2D = scene.nearToFarDistance2D;</span><br><span class="line"></span><br><span class="line">  // The computed near plane must be between the user defined near and far planes.</span><br><span class="line">  // The computed far plane must between the user defined far and computed near.</span><br><span class="line">  // This will handle the <span class="keyword">case</span> <span class="built_in">where</span> the computed near plane is further than the user defined far plane.</span><br><span class="line">  near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);</span><br><span class="line">  far = Math.max(Math.min(far, camera.frustum.far), near);</span><br><span class="line"></span><br><span class="line">  var numFrustums;</span><br><span class="line">  <span class="keyword">if</span> (is2D) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // The multifrustum <span class="keyword">for</span> 3D/CV is non-uniformly distributed.</span><br><span class="line">    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var frustumCommandsList = view.frustumCommandsList;</span><br><span class="line">  frustumCommandsList.length = numFrustums;</span><br><span class="line">  <span class="keyword">for</span> (var m = 0; m &lt; numFrustums; ++m) &#123;</span><br><span class="line">    var curNear;</span><br><span class="line">    var curFar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is2D) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);</span><br><span class="line">      curFar = Math.min(far, farToNearRatio * curNear);</span><br><span class="line">    &#125;</span><br><span class="line">    var frustumCommands = frustumCommandsList[m];</span><br><span class="line">    <span class="keyword">if</span> (!defined(frustumCommands)) &#123;</span><br><span class="line">      frustumCommands = frustumCommandsList[m] = new FrustumCommands(</span><br><span class="line">        curNear,</span><br><span class="line">        curFar</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      frustumCommands.near = curNear;</span><br><span class="line">      frustumCommands.far = curFar;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在View.prototype.createPotentiallyVisibleSet方法中有必要说一下_commandExtents这个数组，其实很简单就是在DrawCommand真正加入到view.frustumCommandsList中之前临时存放的数组，数组中的每个CommandExtent存放了DrawCommand和DrawCommand的near/far（准确说是commandNear/commandFar），根据视锥体数量来将_commandExtents数组中的DrawCommand分别添加到view.frustumCommandsList的不同视锥体指令数组之中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">CommandExtent</span></span>() &#123;</span><br><span class="line">  this.command = undefined;</span><br><span class="line">  this.near = undefined;</span><br><span class="line">  this.far = undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 至此，View.prototype.createPotentiallyVisibleSet方法中计算视锥体数量和相机远近截面的重要点都已经介绍了，接下来整体的讲一遍流程（一定要去打个断点再结合本文来理解）：</p>
<ol>
<li>获取frameState.commandList（在这一帧渲染之前所有的DrawCommand都将存在这个数组）；scene._computeCommandList和scene._overlayCommandList中分别用来存放通用GPU计算的Command（以后再讨论这个东西）和覆盖物的Command。</li>
<li>获取cullingVolume和occluder，对cullingVolume进行操作，总起来一句话：视锥体由六个面构成，去掉远截面。</li>
<li>遍历frameState.commandList数组，根据command.pass来区分是什么类型的渲染指令，pass === Pass.COMPUTE就将command添加到scene._computeCommandList中，pass === Pass.OVERLAY就将command添加到scene._overlayCommandList，这两个类型比较特殊。其他的command都将进行if/else判断：有无boundingVolume（包围球）—&gt;是否是ClearCommand清除指令—&gt;以及其他：</li>
</ol>
<hr>
<p>有无boundingVolume（包围球）：执行这个条件的代码是最复杂的；首先根据boundingVolume/cullingVolume/occluder对进行command进行选择，scene.isVisible在上文已经讲过了，被留下来的都是可渲染的command，根据包围球和相机位置方向计算commandNear/commandFar，参与near/far累计，然后被添加进commandExtents数组中。<br>是否是ClearCommand清除指令：清除指令则直接将command和相机的near/far添加进commandExtents数组中，不参与near/far累计。<br>以及其他：执行这个条件的代码是参与near/far累计操作的，它的累计是使用的相机near/far，然后添加进commandExtents数组中。</p>
<hr>
<p>4.累计完near/far，并将所有符合条件的command添加到commandExtents之后，就将进行视锥体个数的计算updateFrustums，创建对应的FrustumCommands并存在view.frustumCommandsList之中。<br>5.遍历commandExtents数组将其中的command分别存储到不同的视锥体中FrustumCommands，注意：如果一个command被两个视锥体同时占有，则需要分别加入到两个视锥体指令之中，此处也是多视锥体渲染解决深度问题的性能问题所在，因为跨视锥体的command需要渲染两次。<br>6.最后将commandExtents数组进行清除操作，将所有视锥体的远近截面值存储到frameState.frustumSplits数组中（主要用于调试用）；提示：看这部分源码会注意到，代码中有关于shadow的near/far相关计算，因为阴影的生成也是与相机相关的，near/far是必须的，这里就不讨论了。<br>&ensp; &ensp; &ensp; 总结：文首说过“多视椎体渲染”是为了解决深度冲突的问题；Cesium通过所有的的DrawCommand累计出相机最终的near和far，并通过一个公式确定在这一帧需要多少个视椎体进行渲染，然后将command分别存储在不同视椎体中，上面我们提到过一个结论：经过矩阵变换最终写入深度缓冲区的深度值是“片元距离相机视锥体近截面的距离”；也就是说相机的near越接近command，command的片元深度值就越小；所以累计计算near和far以及视椎体数量都是为了使command离相机的near面更近，深度值精度更高！如果有多个视椎体的话，cesium会遍历所有视椎体（最多三个），从后往前渲染，最远处的视椎体渲染完之后，清除深度，再使用下一个视椎体渲染，渲染完清除深度以此类推。</p>
<h2 id="4-对数深度"><a href="#4-对数深度" class="headerlink" title="4. 对数深度"></a>4. 对数深度</h2><p><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/depth.jpg" alt="曲线比较"><br>&ensp; &ensp; &ensp; 在第一小节中提到了WebGL扩展EXT_frag_depth，Cesium中的对数深度需要这个扩展（其他基于WebGL的引擎的对数深度实现都需要），因为在片元着色器中需要使用gl_FragDepthEXT来修改即将写入ZBuffer中的深度值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 顶点着色器</span><br><span class="line"></span><br><span class="line">varying <span class="built_in">float</span> v_depthFromNearPlusOne;</span><br><span class="line">uniform vec2 czm_currentFrustum;// vec2(near,far)</span><br><span class="line">vec4 czm_updatePositionDepth(vec4 coords) &#123;</span><br><span class="line">   coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;</span><br><span class="line">   <span class="built_in">return</span> coords;</span><br><span class="line">&#125;</span><br><span class="line">void czm_vertexLogDepth()</span><br><span class="line">&#123;</span><br><span class="line">   v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;</span><br><span class="line">   gl_Position = czm_updatePositionDepth(gl_Position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 片元着色器</span><br><span class="line"></span><br><span class="line">varying <span class="built_in">float</span> v_depthFromNearPlusOne;</span><br><span class="line">uniform <span class="built_in">float</span> czm_farDepthFromNearPlusOne;// far -near + 1.0</span><br><span class="line">uniform <span class="built_in">float</span> czm_oneOverLog2FarDepthFromNearPlusOne;</span><br><span class="line"></span><br><span class="line">void czm_writeLogDepth(<span class="built_in">float</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (depth &lt;= 0.9999999 || depth &gt; czm_farDepthFromNearPlusOne) &#123;</span><br><span class="line">      discard;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">czm_writeLogDepth</span></span>() &#123;</span><br><span class="line">   czm_writeLogDepth(v_depthFromNearPlusOne);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp; &ensp; &ensp;上面代码是顶点着色器和片元着色器与对数深度相关的代码，在Cesium-Shader中这块代码还有其他处理，为了方便理解我做过精简。这里我要做一个说明：在上一节中我们计算过多视椎体，在使用对数深度开启时（scene.logarithmicDepthBuffer = true）,多视椎体的计算还是需要的，只不过参与计算的系数farToNearRatio不同(numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio)))。通过logarithmicDepthFarToNearRatio参与计算之后视椎体数量会减少，上面有张图可以说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * The far-to-near ratio of the multi-frustum when using a normal depth buffer.</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * This value is used to create the near and far values <span class="keyword">for</span> each frustum of the multi-frustum. It is only used</span><br><span class="line">   * when &#123;@link Scene<span class="comment">#logarithmicDepthBuffer&#125; is &lt;code&gt;false&lt;/code&gt;. When &lt;code&gt;logarithmicDepthBuffer&lt;/code&gt; is</span></span><br><span class="line">   * &lt;code&gt;<span class="literal">true</span>&lt;/code&gt;, use &#123;@link Scene<span class="comment">#logarithmicDepthFarToNearRatio&#125;.</span></span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @default 1000.0</span><br><span class="line">   */</span><br><span class="line">this.farToNearRatio = 1000.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * This value is used to create the near and far values <span class="keyword">for</span> each frustum of the multi-frustum. It is only used</span><br><span class="line">   * when &#123;@link Scene<span class="comment">#logarithmicDepthBuffer&#125; is &lt;code&gt;true&lt;/code&gt;. When &lt;code&gt;logarithmicDepthBuffer&lt;/code&gt; is</span></span><br><span class="line">   * &lt;code&gt;<span class="literal">false</span>&lt;/code&gt;, use &#123;@link Scene<span class="comment">#farToNearRatio&#125;.</span></span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @default 1e9</span><br><span class="line">   */</span><br><span class="line">this.logarithmicDepthFarToNearRatio = 1e9;</span><br></pre></td></tr></table></figure>
<p>&ensp; &ensp; &ensp;对数深度的处理核心就是着色器当中的重新计算片元深度的代码，大家可以把深度计算公式在Graph中看一眼函数图像，一切都明白了！depth值越大，经过log之后曲线增长越缓，这说明什么？这说明片元离相机近截面越远，经过log算出来的depth值会比线性计算出来的值要小很多，值小，精度就够了！</p>
<blockquote><p>文章中有任何错误，请批评勘正</p>
<footer><strong>@superman 1780721345@qq.com</strong></footer></blockquote>


         
      </div> -->
      <div class="article-entry" itemprop="articleBody">
         
         
         
         <p>&ensp; &ensp; &ensp; 在Cesium引擎中深度冲突（Z-Fighting）是绕不开的。之所以会产生深度冲突，是因为两个表面过于接近，深度缓冲区有限的精度已经不能区分哪个在前哪个在后。解决深度冲突问题普遍的方法有“对数深度”和“多边形偏移”，在Cesium当中解决该问题有两种方式“多视锥体”和“多视锥体+对数深度”。<br>&ensp; &ensp; &ensp; GIS-地球渲染的是行星级别的比例尺，用米度量的分辨率会出现深度冲突和抖动的现象。这里作者使用的是Cesium-1.71版本。关于深度冲突本质上是数值的精度问题，Cesium引擎中处理精度问题还有两种方式RTC和RTE，请结合《Cesium-Precision 精度问题》一文来理解。</p>
         
         <p class="article-more-link">
            <a href="/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/#more">Read More</a>
         </p>
         
         
         
      </div>
      <footer class="article-footer">
         <a data-url="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/" data-id="cl5bu37470004x0qt8veg62ro" class="article-share-link">Share</a>
         
         
      </footer>
   </div>
   
</article>


  
    <article id="post-5-Cesium-地球瓦片遮挡计算" class="article article-type-post" itemscope
   itemprop="blogPost">
   <div class="article-meta">
      <a href="/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/" class="article-date">
  <time datetime="2021-01-04T07:07:45.000Z" itemprop="datePublished">2021-01-04</time>
</a>
      
   </div>
   <div class="article-inner">
      
      
      <header class="article-header">
         
  
    <h1 itemprop="name">
      <a class="article-title" href="/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/">Cesium-地球瓦片遮挡计算</a>
    </h1>
  

      </header>
      
      <!-- <div class="article-entry" itemprop="articleBody">
         
         <p>&ensp; &ensp; &ensp; 关于在地球上判断一个Tile（或者其他几何体）是否可见的计算是十分必要的，尤其是在GIS引擎当中，如何能精准的计算出一个Tile是否可见决定着与这个Tile相关的资源（纹理切片/地形数据）是否下载以及这个Tile是否需要渲染。由于地球的影响，视锥体剔除这种过滤方式不能够满足Tile是否可见的判断，因为即使在视锥体之内，地球背面的Tile是无法断定是否可见的。因此Horizon Culling（习惯叫做“地平线剔除”）应运而生。</p>
<h2 id="1-Horizon-Culling"><a href="#1-Horizon-Culling" class="headerlink" title="1. Horizon Culling"></a>1. Horizon Culling</h2><p>&ensp; &ensp; &ensp; 如下图所示，白实线为相机视锥体，白虚线为viewer（相机）与地球切线（地平线），红点位于视锥体之外，绿点和蓝点位于视锥体之内，但是绿点都是可见的（没有地球遮挡），蓝点虽然在视锥体之内，但是却被地球遮挡了（即不可见也就是不可渲染），那么如何判定蓝点是否可见呢？</p>
<p><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/shizhuiti.jpg" alt="剔除"></p>
<p>&ensp; &ensp; &ensp; 如下图所示，首先将地球抽象为一个单位球（unit-sphere即半径为1，至于如何抽象下面会详细介绍），由viewer发出的两条射线与球向切（地平线），实际上与单位球相切的线会有无数条，它们组成一个圆锥（自行脑补）。图中灰色阴影部分就是从viewer方向看被单位球遮挡住的部分。可以这样说，位于圆锥的底面之前的是可见的，位于之后的是不可见的，问题就变成了“一个点在一个面的前面还是后面”。</p>
<p><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/shuxuemoxing.jpg" alt="构建数学计算模型"></p>
<p>&ensp; &ensp; &ensp; 如下图所示，T为处于视锥内的任一点，要想判断T是在圆锥底面之前还是之后很简单，就看VT在VC方向上的投影距离VQ，如果VQ &gt; VP则该点被地球遮蔽，如果VQ &lt; VP则该点未被遮蔽；具体推到计算过程其实是很简单的，因为这个球是单位球即HC=1，V是相机位置，C为地球原点，把VP求出来应该算是初一下学期期末考试的题吧？求出VT的投影VQ应该是算是胎教题吧？<br>&ensp; &ensp; &ensp; 能够判定视锥体内任意一个点在圆锥底面的前后就万无一失了吗？当然不是！看一看第一张图最下边那个绿点，向VC投影之后在要大于VP，但是它可没有被遮挡！所以还需要一个判断，判断“一个点是否在圆锥中，这个圆锥是个底部无限延长的”。</p>
<p><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/mianjisuan.jpg" alt="面测试"></p>
<p>&ensp; &ensp; &ensp; 如下图所示，判断一个点是否在无限锥之内，只需要比夹角大小就可以了。至于计算太简单了就不用说了！</p>
<p><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/zhuijisuan.jpg" alt="无限锥测试"></p>
<p>&ensp; &ensp; &ensp; 一个十分重要的问题：上文总是说单位球，为什么要构造单位球呢？定义一个三维球的标准方程：(x - a)2 + (y - b)2 + (z - c)2 = r2，单位球方程为：x2 + y2 + z2 = 1，定义一个单位椭球的方程为：x2/a2 + y2/b2 + z2/c2 = 1，由公式可以看出(x/a)2 + (y/b)2 + (z/c)2 = 1, 单位椭球其实从某种意义上说是单位球在xyz轴上的缩放，将一个坐标的xyz分别除以椭球的三个轴半径即可将椭球坐标转换到单位球坐标系中（Cesium称为椭球缩放坐标系 ellipsoid-scaled space），代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// Ellipsoid radii - WGS84 shown here</span><br><span class="line">var rX = 6378137.0;</span><br><span class="line">var rY = 6378137.0;</span><br><span class="line">var rZ = 6356752.3142451793;</span><br><span class="line"></span><br><span class="line">// Vector CV</span><br><span class="line">var cvX = cameraPosition.x / rX;</span><br><span class="line">var cvY = cameraPosition.y / rY;</span><br><span class="line">var cvZ = cameraPosition.z / rZ;</span><br><span class="line"></span><br><span class="line">// VH</span><br><span class="line">var vhMagnitudeSquared = cvX * cvX + cvY * cvY + cvZ * cvZ - 1.0;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Target position, transformed to scaled space</span><br><span class="line">var tX = position.x / rX;</span><br><span class="line">var tY = position.y / rY;</span><br><span class="line">var tZ = position.z / rZ;</span><br><span class="line"></span><br><span class="line">// Vector VT</span><br><span class="line">var vtX = tX - cvX;</span><br><span class="line">var vtY = tY - cvY;</span><br><span class="line">var vtZ = tZ - cvZ;</span><br><span class="line">var vtMagnitudeSquared = vtX * vtX + vtY * vtY + vtZ * vtZ;</span><br><span class="line"></span><br><span class="line">// VT dot VC is the inverse of VT dot CV</span><br><span class="line">var vtDotVc = -(vtX * cvX + vtY * cvY + vtZ * cvZ);</span><br><span class="line"></span><br><span class="line">// 通过判断是否在无限锥内外和圆锥底面前后来决定是否遮蔽</span><br><span class="line">var isOccluded = vtDotVc &gt; vhMagnitudeSquared &amp;&amp; </span><br><span class="line">                vtDotVc * vtDotVc / vtMagnitudeSquared &gt; vhMagnitudeSquared;</span><br></pre></td></tr></table></figure>

<h2 id="2-Computing-the-horizon-occlusion-point"><a href="#2-Computing-the-horizon-occlusion-point" class="headerlink" title="2. Computing the horizon occlusion point"></a>2. Computing the horizon occlusion point</h2><p>&ensp; &ensp; &ensp; 上文我们仅仅是判断一个点在viewer方向上是否被地球遮蔽，那么问题来了，如果是一个地形Tile呢？总不能遍历这个Tile所有的顶点来判断其是否被遮蔽吧？Cesium中的解决办法是将Tile计算出一个遮蔽点，通过这个遮蔽点来参与第一节的计算，就能够判断这个Tile是否被遮挡。记得某位前辈曾说过，图形学搞到底全都是数学问题，这在Cesium中体现的淋漓尽致。</p>
<p><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/goujian.jpg" alt="遮蔽点计算"></p>
<p>&ensp; &ensp; &ensp; 如上图所示，蓝色球为单位球（unit-sphere），棕色几何体为地形Tile，OC是从单位球心到Tile包围体（可能是包围球也可能是旋转包围盒，不过这都不重要，我们只要其center点）中心点C发出的一条射线，V是Tile上的一个顶点，H是V与单位球的切线，其实V与单位球有无数个切线，但是只有两条切线会与OC相交（H-V-P和虚线），通过遍历Tile所有顶点计算顶点与单位球切线和OC的交点，找出最大的OP距离，这个最大的OP距离的P交点，即为所要得到的 horizon occlusion point。</p>
<p><img src="/ThreeDimensional/SuperManZTF/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/zhebidian.jpg" alt="遮蔽点计算"></p>
<p>&ensp; &ensp; &ensp; 如上图所示，关于遮蔽点的具体计算无非就是求切线求交点等问题，很简单的立体几何计算，此处就不啰里啰唆了。为什么说最大的OP即在OC方向上最远的交点P就是遮蔽点呢？为什么通过判断这个点就可以决定这个Tile是否被地球遮挡呢？我们可以想象一下，从Viewer方向看，一个Tile是否被地球遮蔽，取决于一个很要的东西：切线（地平线），主动权在Viewer这里，现在换个思路，如果我们从Tile的每个顶点看相机呢？最早看到相机的那个顶点与单位球的切线HV与OC的交点就是P！相机最早看到P就相当于看到Tile的V点了！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">// EllipsoidalOccluder.js</span><br><span class="line">/**</span><br><span class="line"> * 计算遮蔽点（注意需要转换到椭球缩放空间）</span><br><span class="line"> * @param ellipsoid WGS84椭球对象</span><br><span class="line"> * @param directionToPoint Tile中心点</span><br><span class="line"> * @param positions Tile的四个点（此处注意上文说到遍历Tile的顶点是不对的，</span><br><span class="line"> *   首先此处尚且没有Tile的网格数据，其次遍历顶点性能太差）</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> computeHorizonCullingPointFromPositions(</span><br><span class="line">  ellipsoid,</span><br><span class="line">  directionToPoint,</span><br><span class="line">  positions,</span><br><span class="line">  result</span><br><span class="line">) &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!defined(result)) &#123;</span><br><span class="line">    result = new Cartesian3();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var scaledSpaceDirectionToPoint = computeScaledSpaceDirectionToPoint(</span><br><span class="line">    ellipsoid,</span><br><span class="line">    directionToPoint</span><br><span class="line">  );</span><br><span class="line">  var resultMagnitude = 0.0;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var i = 0, len = positions.length; i &lt; len; ++i) &#123;</span><br><span class="line">    var position = positions[i];</span><br><span class="line">    var candidateMagnitude = computeMagnitude(</span><br><span class="line">      ellipsoid,</span><br><span class="line">      position,</span><br><span class="line">      scaledSpaceDirectionToPoint</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (candidateMagnitude &lt; 0.0) &#123;</span><br><span class="line">      // all points should face the same direction, but this one doesnt, so <span class="built_in">return</span> undefined</span><br><span class="line">      <span class="built_in">return</span> undefined;</span><br><span class="line">    &#125;</span><br><span class="line">    resultMagnitude = Math.max(resultMagnitude, candidateMagnitude);// 找出最大OP</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> magnitudeToPoint(scaledSpaceDirectionToPoint, resultMagnitude, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 对于上述代码，只提醒一点：主要将坐标转换到椭球缩放空间，算完之后在转换回去！！！</p>
<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>&ensp; &ensp; &ensp; 在文章开头就说过，以上计算解决了Tile在视锥体之内的地球遮蔽问题，能够判定在视锥体之内，从相机方向看地球背面瓦片是否被遮挡，从而决定Tile是否加载资源是否渲染等，这个过滤很重要！但是在Tile真正组装成DrawCommand之后，这个渲染指令会不会渲染还要经过判断！这跟相机视锥体/Tile包围球/occluder有关，具体计算原理和过程以后再讨论，代码如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Scene.prototype.isVisible = <span class="keyword">function</span> (<span class="built_in">command</span>, cullingVolume, occluder) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    defined(<span class="built_in">command</span>) &amp;&amp;</span><br><span class="line">    (!defined(command.boundingVolume) ||</span><br><span class="line">      !command.cull ||</span><br><span class="line">      (cullingVolume.computeVisibility(command.boundingVolume) !==</span><br><span class="line">        Intersect.OUTSIDE &amp;&amp;</span><br><span class="line">        (!defined(occluder) ||</span><br><span class="line">          !command.occlude ||</span><br><span class="line">          !command.boundingVolume.isOccluded(occluder))))</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 本篇博客参考Cesium两篇文章，特此注明！</p>
<blockquote><p>文章中有任何错误，请批评勘正</p>
<footer><strong>@superman 1780721345@qq.com</strong></footer></blockquote>

         
      </div> -->
      <div class="article-entry" itemprop="articleBody">
         
         
         
         <p>&ensp; &ensp; &ensp; 关于在地球上判断一个Tile（或者其他几何体）是否可见的计算是十分必要的，尤其是在GIS引擎当中，如何能精准的计算出一个Tile是否可见决定着与这个Tile相关的资源（纹理切片/地形数据）是否下载以及这个Tile是否需要渲染。由于地球的影响，视锥体剔除这种过滤方式不能够满足Tile是否可见的判断，因为即使在视锥体之内，地球背面的Tile是无法断定是否可见的。因此Horizon Culling（习惯叫做“地平线剔除”）应运而生。</p>
         
         <p class="article-more-link">
            <a href="/ThreeDimensional/2021/01/04/5-Cesium-地球瓦片遮挡计算/#more">Read More</a>
         </p>
         
         
         
      </div>
      <footer class="article-footer">
         <a data-url="https://github.com/SuperManZTF/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/" data-id="cl5bu37460003x0qt1mvo9yqd" class="article-share-link">Share</a>
         
         
      </footer>
   </div>
   
</article>


  
    <article id="post-4-Cesium-DrawCommand" class="article article-type-post" itemscope
   itemprop="blogPost">
   <div class="article-meta">
      <a href="/ThreeDimensional/2020/11/08/4-Cesium-DrawCommand/" class="article-date">
  <time datetime="2020-11-08T04:52:34.000Z" itemprop="datePublished">2020-11-08</time>
</a>
      
   </div>
   <div class="article-inner">
      
      
      <header class="article-header">
         
  
    <h1 itemprop="name">
      <a class="article-title" href="/ThreeDimensional/2020/11/08/4-Cesium-DrawCommand/">Cesium-DrawCommand</a>
    </h1>
  

      </header>
      
      <!-- <div class="article-entry" itemprop="articleBody">
         
         <p>&ensp; &ensp; &ensp; 在Cesium当中不管影像/地形/倾斜摄影如何调度，还是在地球之上任何绘制几何体，最终都会组装成一个DrawCommand渲染指令；然后将DrawCommand送入Context中执行渲染任务。</p>
<h2 id="1-DrawCommand中有什么？"><a href="#1-DrawCommand中有什么？" class="headerlink" title="1. DrawCommand中有什么？"></a>1. DrawCommand中有什么？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> DrawCommand(options) &#123;</span><br><span class="line">  this._boundingVolume = options.boundingVolume;// 包围球</span><br><span class="line">  this._orientedBoundingBox = options.orientedBoundingBox;// 旋转包围盒</span><br><span class="line">  this._cull = defaultValue(options.cull, <span class="literal">true</span>);// 是否进行视锥剔除，这涉及到View.js里面的指令过滤</span><br><span class="line">  this._occlude = defaultValue(options.occlude, <span class="literal">true</span>);// 是否进行地球遮蔽判断，这涉及到View.js里面的指令过滤</span><br><span class="line">  this._modelMatrix = options.modelMatrix;// 模型矩阵，对，就是MVP的M</span><br><span class="line">  this._primitiveType = defaultValue(// WebGL渲染几何体的类型 点 线 面...</span><br><span class="line">    options.primitiveType,</span><br><span class="line">    PrimitiveType.TRIANGLES</span><br><span class="line">  );</span><br><span class="line">  this._vertexArray = options.vertexArray;// 顶点属性数据 VAO</span><br><span class="line">  this._count = options.count;// 顶点数量</span><br><span class="line">  this._offset = defaultValue(options.offset, 0);// 顶点偏移</span><br><span class="line">  this._instanceCount = defaultValue(options.instanceCount, 0);// 实例化渲染数量</span><br><span class="line">  this._shaderProgram = options.shaderProgram;// 着色程序</span><br><span class="line">  this._uniformMap = options.uniformMap;// 纹理贴图</span><br><span class="line">  this._renderState = options.renderState;// 渲染状态：深度/模板/颜色缓冲操作设置（例如 禁止模板测试 禁止颜色写入等）</span><br><span class="line">  this._framebuffer = options.framebuffer;// 当前DrawCommand渲染所用的FBO</span><br><span class="line">  this._pass = options.pass;// 当前DrawCommand所属的Pass，Pass用来控制先后渲染顺序</span><br><span class="line">  this._executeInClosestFrustum = defaultValue(</span><br><span class="line">    options.executeInClosestFrustum,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  this._owner = options.owner;// 所对应的逻辑对象,例如某个地块的DrawCommand属于QuadtreeTile实例</span><br><span class="line">  this._debugShowBoundingVolume = defaultValue(// 是否调试包围体，会打开这个DrawCommand包围体</span><br><span class="line">    options.debugShowBoundingVolume,</span><br><span class="line">    <span class="literal">false</span></span><br><span class="line">  );</span><br><span class="line">  this._debugOverlappingFrustums = 0;</span><br><span class="line">  this._castShadows = defaultValue(options.castShadows, <span class="literal">false</span>);// 产生阴影</span><br><span class="line">  this._receiveShadows = defaultValue(options.receiveShadows, <span class="literal">false</span>);// 接受阴影</span><br><span class="line">  this._pickId = options.pickId;// 拾取ID，这里涉及到Cesium中的GPUPicker拾取机制</span><br><span class="line">  this._pickOnly = defaultValue(options.pickOnly, <span class="literal">false</span>);// 是否只用于拾取，这里涉及到Cesium中的GPUPicker拾取机制</span><br><span class="line"></span><br><span class="line">  this.dirty = <span class="literal">true</span>;</span><br><span class="line">  this.lastDirtyTime = 0;</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * @private</span><br><span class="line">   */</span><br><span class="line">  this.derivedCommands = &#123;&#125;;// 衍生指令，这里涉及到HDR/对数深度/阴影的处理，在原来指令的基础上衍生其他功能，例如增加shader代码块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 由上面的代码以及注释可以看出，DrawCommand中包含了渲染一个对象所需的各种信息，顶点属性/FBO/Depth||Color||Stencil/纹理/Shader等。将这个类的实例执行excute方法即可使用Context对其进行渲染，Context封装了WebGL上下文，是直接面向GL的。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Executes the draw <span class="built_in">command</span>.</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Context&#125; context The renderer context <span class="keyword">in</span> <span class="built_in">which</span> to draw.</span><br><span class="line"> * @param &#123;PassState&#125; [passState] The state <span class="keyword">for</span> the current render pass.</span><br><span class="line"> */</span><br><span class="line">DrawCommand.prototype.execute = <span class="keyword">function</span> (context, passState) &#123;</span><br><span class="line">  context.draw(this, passState);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 上面代码中尤其值得注意的是passState这个参数，这个对象很重要！！！在DrawCommand中有一个_framebuffer变量，当这个变量不为Undefined时，说明这个渲染指令将绘制到挂载的这个FBO中，否则将绘制到passState中的FBO上。</p>
<blockquote><p>文章中有任何错误，请批评勘正</p>
<footer><strong>@superman 1780721345@qq.com</strong></footer></blockquote>

         
      </div> -->
      <div class="article-entry" itemprop="articleBody">
         
         
         
         <p>&ensp; &ensp; &ensp; 在Cesium当中不管影像/地形/倾斜摄影如何调度，还是在地球之上任何绘制几何体，最终都会组装成一个DrawCommand渲染指令；然后将DrawCommand送入Context中执行渲染任务。</p>
         
         <p class="article-more-link">
            <a href="/ThreeDimensional/2020/11/08/4-Cesium-DrawCommand/#more">Read More</a>
         </p>
         
         
         
      </div>
      <footer class="article-footer">
         <a data-url="https://github.com/SuperManZTF/ThreeDimensional/2020/11/08/4-Cesium-DrawCommand/" data-id="cl5bu37440002x0qt934t5j9s" class="article-share-link">Share</a>
         
         
      </footer>
   </div>
   
</article>


  
    <article id="post-3-Cesium-Pass" class="article article-type-post" itemscope
   itemprop="blogPost">
   <div class="article-meta">
      <a href="/ThreeDimensional/2020/11/08/3-Cesium-Pass/" class="article-date">
  <time datetime="2020-11-08T04:48:26.000Z" itemprop="datePublished">2020-11-08</time>
</a>
      
   </div>
   <div class="article-inner">
      
      
      <header class="article-header">
         
  
    <h1 itemprop="name">
      <a class="article-title" href="/ThreeDimensional/2020/11/08/3-Cesium-Pass/">Cesium-Pass 渲染对象类型</a>
    </h1>
  

      </header>
      
      <!-- <div class="article-entry" itemprop="articleBody">
         
         <p>&ensp; &ensp; &ensp; 如果理解cesium引擎的渲染模块，最好的入口在哪？我觉得是Context和Pass两个类还有Scene.executeCommands这个方法。Pass中定义了引擎所能渲染的对象类型，cesium不管影像地形倾斜如何调度，最终都是要生成DrawCommand（渲染指令），而这些渲染指令存放在view.frustumCommandsList中（参考《Cesium-Z-Fighting 深度冲突问题》-多视锥体渲染），cesium在Scene.executeCommands方法中会根据pass拿到不同类型的指令去context中执行渲染，不同类型的DrawCommand是有渲染顺序的！</p>
<h2 id="1-Pass"><a href="#1-Pass" class="headerlink" title="1. Pass"></a>1. Pass</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var Pass = &#123;</span><br><span class="line">  ENVIRONMENT: 0,// 环境</span><br><span class="line">  COMPUTE: 1,// 通用计算</span><br><span class="line">  GLOBE: 2,// 影像 地形</span><br><span class="line">  TERRAIN_CLASSIFICATION: 3,// 地形相关物体</span><br><span class="line">  CESIUM_3D_TILE: 4,// 3D Tiles</span><br><span class="line">  CESIUM_3D_TILE_CLASSIFICATION: 5,// 3D Tiles相关物体</span><br><span class="line">  CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW: 6,</span><br><span class="line">  OPAQUE: 7,// 不透明物体</span><br><span class="line">  TRANSLUCENT: 8,// 半透明物体</span><br><span class="line">  OVERLAY: 9,// 覆盖物</span><br><span class="line">  NUMBER_OF_PASSES: 10,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 这个类定义了十种渲染类型，ENVIRONMENT背景天空盒大气，COMPUTE通用GPU计算（以后有时间再讨论，涉及到浮点纹理）。GLOBE影像地形，TERRAIN_CLASSIFICATION地形相关物例如贴底线，CESIUM_3D_TILE倾斜摄影，CESIUM_3D_TILE_CLASSIFICATION/CESIUM_3D_TILE_CLASSIFICATION_IGNORE_SHOW倾斜摄影相关物，OPAQUE不透明物体，TRANSLUCENT半透明物体（以后有时间再讨论，涉及到OIT），OVERLAY覆盖物例如标牌</p>
<h2 id="2-FrustumCommands"><a href="#2-FrustumCommands" class="headerlink" title="2. FrustumCommands"></a>2. FrustumCommands</h2><p>&ensp; &ensp; &ensp; 这个类在多视锥体渲染中涉及到过，挂在view.frustumCommandsList中。在Scene.executeCommands中会遍历frustumCommandsList获取FrustumCommands对象，然后重点来了，根据渲染顺序会通过Pass来在FrustumCommands对象中找到所有DrawCommand。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> FrustumCommands(near, far) &#123;</span><br><span class="line">  this.near = defaultValue(near, 0.0);</span><br><span class="line">  this.far = defaultValue(far, 0.0);</span><br><span class="line"></span><br><span class="line">  var numPasses = Pass.NUMBER_OF_PASSES;</span><br><span class="line">  var commands = new Array(numPasses);</span><br><span class="line">  var indices = new Array(numPasses);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; numPasses; ++i) &#123;</span><br><span class="line">    commands[i] = [];</span><br><span class="line">    indices[i] = 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this.commands = commands;</span><br><span class="line">  this.indices = indices;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在FrustumCommands类中commands是个数组，这个数组中根据Pass的不同类型存放了不同类型的DrawCommand。而indices则是存放着不同类型DrawCommand的个数！！！最好去打个断点理解一下。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">us.updatePass(Pass.GLOBE);</span><br><span class="line">var commands = frustumCommands.commands[Pass.GLOBE];</span><br></pre></td></tr></table></figure>

<h2 id="3-cesium渲染顺序"><a href="#3-cesium渲染顺序" class="headerlink" title="3.cesium渲染顺序"></a>3.cesium渲染顺序</h2><p>&ensp; &ensp; &ensp; Scene.executeCommands中是引擎集中处理Command的地方，在这个方法中根据Pass的不同按顺序进行渲染。下面我用伪代码来描述这个过程：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> executeCommands(scene, passState) &#123;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">    us.updatePass(Pass.ENVIRONMENT);</span><br><span class="line">    <span class="keyword">if</span> (!picking) &#123;</span><br><span class="line">    // 天空盒</span><br><span class="line">    var skyBoxCommand = environmentState.skyBoxCommand;</span><br><span class="line">    <span class="keyword">if</span> (defined(skyBoxCommand)) &#123;</span><br><span class="line">      executeCommand(skyBoxCommand, scene, context, passState);</span><br><span class="line">    &#125;</span><br><span class="line">    // 大气</span><br><span class="line">    <span class="keyword">if</span> (environmentState.isSkyAtmosphereVisible) &#123;</span><br><span class="line">      executeCommand(</span><br><span class="line">        environmentState.skyAtmosphereCommand,</span><br><span class="line">        scene,</span><br><span class="line">        context,</span><br><span class="line">        passState</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    // 太阳</span><br><span class="line">    <span class="keyword">if</span> (environmentState.isSunVisible) &#123;</span><br><span class="line">      environmentState.sunDrawCommand.execute(context, passState);</span><br><span class="line">    &#125;</span><br><span class="line">    // 月亮</span><br><span class="line">    <span class="keyword">if</span> (environmentState.isMoonVisible) &#123;</span><br><span class="line">      environmentState.moonCommand.execute(context, passState);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">  // numFrustums多视锥体渲染</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; numFrustums; ++i) &#123;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">    // 绘制地球影像和地形</span><br><span class="line">    us.updatePass(Pass.GLOBE);</span><br><span class="line">    var commands = frustumCommands.commands[Pass.GLOBE];</span><br><span class="line">    var length = frustumCommands.indices[Pass.GLOBE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (globeTranslucent) &#123;</span><br><span class="line">        ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (j = 0; j &lt; length; ++j) &#123;</span><br><span class="line">        executeCommand(commands[j], scene, context, passState);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">    // Draw terrain classification 例如 贴地线 贴地面</span><br><span class="line">    <span class="keyword">if</span> (!environmentState.renderTranslucentDepthForPick) &#123;</span><br><span class="line">      us.updatePass(Pass.TERRAIN_CLASSIFICATION);</span><br><span class="line">      commands = frustumCommands.commands[Pass.TERRAIN_CLASSIFICATION];</span><br><span class="line">      length = frustumCommands.indices[Pass.TERRAIN_CLASSIFICATION];</span><br><span class="line">      <span class="keyword">if</span> (globeTranslucent) &#123;</span><br><span class="line">        ......</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = 0; j &lt; length; ++j) &#123;</span><br><span class="line">          executeCommand(commands[j], scene, context, passState);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">    // 与3D Tiles相关的绘制处理</span><br><span class="line">    <span class="keyword">if</span> (...) &#123;</span><br><span class="line">      // Draw 3D Tiles</span><br><span class="line">      us.updatePass(Pass.CESIUM_3D_TILE);</span><br><span class="line">      commands = frustumCommands.commands[Pass.CESIUM_3D_TILE];</span><br><span class="line">      length = frustumCommands.indices[Pass.CESIUM_3D_TILE];</span><br><span class="line">      <span class="keyword">for</span> (j = 0; j &lt; length; ++j) &#123;</span><br><span class="line">        executeCommand(commands[j], scene, context, passState);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (length &gt; 0) &#123;</span><br><span class="line">        <span class="keyword">if</span> (defined(globeDepth) &amp;&amp; environmentState.useGlobeDepthFramebuffer) &#123;</span><br><span class="line">          globeDepth.executeUpdateDepth(context, passState, clearGlobeDepth);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!environmentState.renderTranslucentDepthForPick) &#123;</span><br><span class="line">          us.updatePass(Pass.CESIUM_3D_TILE_CLASSIFICATION);</span><br><span class="line">          commands =</span><br><span class="line">            frustumCommands.commands[Pass.CESIUM_3D_TILE_CLASSIFICATION];</span><br><span class="line">          length = frustumCommands.indices[Pass.CESIUM_3D_TILE_CLASSIFICATION];</span><br><span class="line">          <span class="keyword">for</span> (j = 0; j &lt; length; ++j) &#123;</span><br><span class="line">            executeCommand(commands[j], scene, context, passState);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">    // 不透明物体绘制处理</span><br><span class="line">    us.updatePass(Pass.OPAQUE);</span><br><span class="line">    commands = frustumCommands.commands[Pass.OPAQUE];</span><br><span class="line">    length = frustumCommands.indices[Pass.OPAQUE];</span><br><span class="line">    <span class="keyword">for</span> (j = 0; j &lt; length; ++j) &#123;</span><br><span class="line">      executeCommand(commands[j], scene, context, passState);</span><br><span class="line">    &#125;</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">    // 半透明物体绘制处理</span><br><span class="line">    us.updatePass(Pass.TRANSLUCENT);</span><br><span class="line">    commands = frustumCommands.commands[Pass.TRANSLUCENT];</span><br><span class="line">    commands.length = frustumCommands.indices[Pass.TRANSLUCENT];</span><br><span class="line">    executeTranslucentCommands(</span><br><span class="line">      scene,</span><br><span class="line">      executeCommand,</span><br><span class="line">      passState,</span><br><span class="line">      commands,</span><br><span class="line">      invertClassification</span><br><span class="line">    );</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp; &ensp; &ensp; 上面描述已经大概说明了cesium的渲染顺序，代码做过精简；其实在整个渲染过程中还涉及到FBO的切换和绑定，尤其是半透明物体OIT的渲染是有些复杂的，还涉及到Scene.resolveFramebuffers方法，threejs中处理半透明是采用Alpha/Blend的方式，这在一些情况下是有问题的。</p>
<blockquote><p>文章中有任何错误，请批评勘正</p>
<footer><strong>@superman 1780721345@qq.com</strong></footer></blockquote>

         
      </div> -->
      <div class="article-entry" itemprop="articleBody">
         
         
         
         <p>&ensp; &ensp; &ensp; 如果理解cesium引擎的渲染模块，最好的入口在哪？我觉得是Context和Pass两个类还有Scene.executeCommands这个方法。Pass中定义了引擎所能渲染的对象类型，cesium不管影像地形倾斜如何调度，最终都是要生成DrawCommand（渲染指令），而这些渲染指令存放在view.frustumCommandsList中（参考《Cesium-Z-Fighting 深度冲突问题》-多视锥体渲染），cesium在Scene.executeCommands方法中会根据pass拿到不同类型的指令去context中执行渲染，不同类型的DrawCommand是有渲染顺序的！</p>
         
         <p class="article-more-link">
            <a href="/ThreeDimensional/2020/11/08/3-Cesium-Pass/#more">Read More</a>
         </p>
         
         
         
      </div>
      <footer class="article-footer">
         <a data-url="https://github.com/SuperManZTF/ThreeDimensional/2020/11/08/3-Cesium-Pass/" data-id="cl5bu373y0000x0qt2yhg02rh" class="article-share-link">Share</a>
         
         
      </footer>
   </div>
   
</article>


  
    <article id="post-2-Cesium-Precision" class="article article-type-post" itemscope
   itemprop="blogPost">
   <div class="article-meta">
      <a href="/ThreeDimensional/2020/11/08/2-Cesium-Precision/" class="article-date">
  <time datetime="2020-11-08T04:47:06.000Z" itemprop="datePublished">2020-11-08</time>
</a>
      
   </div>
   <div class="article-inner">
      
      
      <header class="article-header">
         
  
    <h1 itemprop="name">
      <a class="article-title" href="/ThreeDimensional/2020/11/08/2-Cesium-Precision/">Cesium-Precision 精度问题</a>
    </h1>
  

      </header>
      
      <!-- <div class="article-entry" itemprop="articleBody">
         
         <p>&ensp; &ensp; &ensp; 在cesium引擎中处理地球所用的数据都非常大，JS能支持Float64数据精度，但是webgl仅支持Float32精度，所以当由CPU向GPU提交顶点属性数据会产生“精度丢失”，反映在渲染图像上是”闪烁/抖动“等。解决数据精度丢失问题的常用方法有两种：RTC（Relative To Center）和RTE（Relative To Eye），cesium中使用的是RTE这种方式。</p>
<h2 id="1-RTC"><a href="#1-RTC" class="headerlink" title="1. RTC"></a>1. RTC</h2><p>&ensp; &ensp; &ensp; Relative To Center简称RTC，相信大家对webgl的几个重要坐标系都很熟悉（本地坐标系/世界坐标系/相机坐标系/投影坐标系），假如需要构建一个立方体，我们描述顶点的时候不使用世界坐标系下的点来构建（原点在世界坐标系中心），而是选择立方体的中心点作为原点，立方体顶点都是相对中心点给值（值会变小），将立方体放到中心点所在的世界坐标系中，这样的效果会和直接给定立方体世界坐标系下的顶点数据相同！但是顶点数据变小了。<br>&ensp; &ensp; &ensp; 有人可能会问，即使立方体的顶点数据是相对于中心点给定，值确实会变小，但是要想将立方体放到世界坐标系下某位置，需要左乘M矩阵（模型矩阵），这个模型矩阵中的位移部分也是个大值，精度还是会丢失？实际上确实是这样，这个立方体构建的M矩阵位移部分确实值会很大，但是我们可以不需要直接往着色器中传递M矩阵，而是传递MV矩阵！这个矩阵会把M中位移部分的大值抵消掉，在着色器中直接左乘MV矩阵。<br>&ensp; &ensp; &ensp; 特别需要注意：虽然MV矩阵抵消了大的值，但是当相机离立方体很远的时候还是由精度丢失的情况，但是由于渲染对象离得比较远，细节关注度大大下降，所以也没啥问题。一个渲染对象，坐标值非常大，把这些值相对于一个中心点来给定，然后左成MV矩阵不直接左乘M矩阵，在相机离得比较近的时候精度丢失问题可以解决。</p>
<h2 id="2-RTE"><a href="#2-RTE" class="headerlink" title="2. RTE"></a>2. RTE</h2><p>&ensp; &ensp; &ensp; Relative To Eye简称RTE，这种方式和RTC有相似之处，上面顶点数据是相对于中心点给定，而RTE的顶点数据是相对于相机的（Eye）。下面是cesium源码中处理RTE过程，AutomaticUniforms是cesium中自动计算uniform值的类，它会在每帧每个command执行的时候根据着色器需要传入的uniform值的不同而去计算相应uniform，下文中需要的uniform值都在其中自行断点查看。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">EncodedCartesian3</span></span>() &#123;</span><br><span class="line">  this.high = Cartesian3.clone(Cartesian3.ZERO);</span><br><span class="line">  this.low = Cartesian3.clone(Cartesian3.ZERO);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * @example</span><br><span class="line"> * var value = 1234567.1234567;</span><br><span class="line"> * var splitValue = Cesium.EncodedCartesian3.encode(value);</span><br><span class="line"> */</span><br><span class="line">EncodedCartesian3.encode = <span class="keyword">function</span> (value, result) &#123;</span><br><span class="line">  //&gt;&gt;includeStart(<span class="string">&#x27;debug&#x27;</span>, pragmas.debug);</span><br><span class="line">  Check.typeOf.number(<span class="string">&quot;value&quot;</span>, value);</span><br><span class="line">  //&gt;&gt;includeEnd(<span class="string">&#x27;debug&#x27;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!defined(result)) &#123;</span><br><span class="line">    result = &#123;</span><br><span class="line">      high: 0.0,</span><br><span class="line">      low: 0.0,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var doubleHigh;</span><br><span class="line">  <span class="keyword">if</span> (value &gt;= 0.0) &#123;</span><br><span class="line">    doubleHigh = Math.floor(value / 65536.0) * 65536.0;</span><br><span class="line">    result.high = doubleHigh;</span><br><span class="line">    result.low = value - doubleHigh;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    doubleHigh = Math.floor(-value / 65536.0) * 65536.0;</span><br><span class="line">    result.high = -doubleHigh;</span><br><span class="line">    result.low = value + doubleHigh;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 上面这段代码可谓是实现GPU双精度计算的精髓！将一个数值拆分成high和low两部分，即将一个Float64的值拆分成两个Float32的值；上文说过，js支持Float64，webgl仅支持Float32！这样拆分之后往webgl中传递数据精度可以保证了。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">uniform mat4 czm_modelViewRelativeToEye;</span><br><span class="line">attribute vec3 positionHigh;</span><br><span class="line">attribute vec3 positionLow;</span><br><span class="line"></span><br><span class="line">vec4 czm_translateRelativeToEye(vec3 high, vec3 low)</span><br><span class="line">&#123;</span><br><span class="line">  vec3 highDifference = high - czm_encodedCameraPositionMCHigh;</span><br><span class="line">  vec3 lowDifference = low - czm_encodedCameraPositionMCLow;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> vec4(highDifference + lowDifference, 1.0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void main()</span><br><span class="line">&#123;</span><br><span class="line">  vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);</span><br><span class="line">  gl_Position = czm_projection * (czm_modelViewRelativeToEye * p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; czm_modelViewRelativeToEye：相对于相机（Eye）的MV矩阵，左乘可以变换到相机空间<br>&ensp; &ensp; &ensp; positionHigh/positionLow：一个Float64拆分成两个Float32的值<br>&ensp; &ensp; &ensp; czm_encodedCameraPositionMCHigh/czm_encodedCameraPositionMCLow：相机位置（一个Float64拆分成两个Float32的值），一定要注意这个相机位置的坐标系奥！MC MC MC<br>&ensp; &ensp; &ensp; czm_projection：相机投影矩阵<br>&ensp; &ensp; &ensp; 本来在这一段我想详细理一下过程，但是感觉说多了也没用，懂得已经懂了！上面的计算和数据传递，全程避免了大数值！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> cleanModelViewRelativeToEye(uniformState) &#123;</span><br><span class="line">  <span class="keyword">if</span> (uniformState._modelViewRelativeToEyeDirty) &#123;</span><br><span class="line">    uniformState._modelViewRelativeToEyeDirty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    var mv = uniformState.modelView;</span><br><span class="line">    var mvRte = uniformState._modelViewRelativeToEye;</span><br><span class="line">    mvRte[0] = mv[0];</span><br><span class="line">    mvRte[1] = mv[1];</span><br><span class="line">    mvRte[2] = mv[2];</span><br><span class="line">    mvRte[3] = mv[3];</span><br><span class="line">    mvRte[4] = mv[4];</span><br><span class="line">    mvRte[5] = mv[5];</span><br><span class="line">    mvRte[6] = mv[6];</span><br><span class="line">    mvRte[7] = mv[7];</span><br><span class="line">    mvRte[8] = mv[8];</span><br><span class="line">    mvRte[9] = mv[9];</span><br><span class="line">    mvRte[10] = mv[10];</span><br><span class="line">    mvRte[11] = mv[11];</span><br><span class="line">    mvRte[12] = 0.0;</span><br><span class="line">    mvRte[13] = 0.0;</span><br><span class="line">    mvRte[14] = 0.0;</span><br><span class="line">    mvRte[15] = mv[15];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 最后有必要说一下czm_modelViewRelativeToEye这个矩阵是如何构建的，很简单就是MV矩阵去掉位移部分，为什么？因为着色器czm_translateRelativeToEye方法中已经减去相机位置了！！！<br>&ensp; &ensp; &ensp; 这里再次提醒czm_encodedCameraPositionMCHigh和czm_encodedCameraPositionMCLow一定要注意坐标系！！！</p>
<blockquote><p>文章中有任何错误，请批评勘正</p>
<footer><strong>@superman 1780721345@qq.com</strong></footer></blockquote>

         
      </div> -->
      <div class="article-entry" itemprop="articleBody">
         
         
         
         <p>&ensp; &ensp; &ensp; 在cesium引擎中处理地球所用的数据都非常大，JS能支持Float64数据精度，但是webgl仅支持Float32精度，所以当由CPU向GPU提交顶点属性数据会产生“精度丢失”，反映在渲染图像上是”闪烁/抖动“等。解决数据精度丢失问题的常用方法有两种：RTC（Relative To Center）和RTE（Relative To Eye），cesium中使用的是RTE这种方式。</p>
         
         <p class="article-more-link">
            <a href="/ThreeDimensional/2020/11/08/2-Cesium-Precision/#more">Read More</a>
         </p>
         
         
         
      </div>
      <footer class="article-footer">
         <a data-url="https://github.com/SuperManZTF/ThreeDimensional/2020/11/08/2-Cesium-Precision/" data-id="cl5bu37430001x0qt2wqnhgx9" class="article-share-link">Share</a>
         
         
      </footer>
   </div>
   
</article>


  


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/ThreeDimensional/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/ThreeDimensional/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/ThreeDimensional/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/">Cesium-Z-Fighting 深度冲突问题</a>
          </li>
        
          <li>
            <a href="/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/">Cesium-地球瓦片遮挡计算</a>
          </li>
        
          <li>
            <a href="/ThreeDimensional/2020/11/08/4-Cesium-DrawCommand/">Cesium-DrawCommand</a>
          </li>
        
          <li>
            <a href="/ThreeDimensional/2020/11/08/3-Cesium-Pass/">Cesium-Pass 渲染对象类型</a>
          </li>
        
          <li>
            <a href="/ThreeDimensional/2020/11/08/2-Cesium-Precision/">Cesium-Precision 精度问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 SuperMan<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/ThreeDimensional/" class="mobile-nav-link">Home</a>
  
    <a href="/ThreeDimensional/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/ThreeDimensional/fancybox/jquery.fancybox.css">

  
<script src="/ThreeDimensional/fancybox/jquery.fancybox.pack.js"></script>




<script src="/ThreeDimensional/js/script.js"></script>




  </div>
</body>
</html>