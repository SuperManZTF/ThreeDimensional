<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>Cesium-Z-Fighting 深度冲突问题 | SuperMan</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="&amp;ensp; &amp;ensp; &amp;ensp; 在Cesium引擎中深度冲突（Z-Fighting）是绕不开的。之所以会产生深度冲突，是因为两个表面过于接近，深度缓冲区有限的精度已经不能区分哪个在前哪个在后。解决深度冲突问题普遍的方法有“对数深度”和“多边形偏移”，在Cesium当中解决该问题有两种方式“多视锥体”和“多视锥体+对数深度”。&amp;ensp; &amp;ensp; &amp;ensp; GIS-地球渲染的是行">
<meta property="og:type" content="article">
<meta property="og:title" content="Cesium-Z-Fighting 深度冲突问题">
<meta property="og:url" content="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/index.html">
<meta property="og:site_name" content="SuperMan">
<meta property="og:description" content="&amp;ensp; &amp;ensp; &amp;ensp; 在Cesium引擎中深度冲突（Z-Fighting）是绕不开的。之所以会产生深度冲突，是因为两个表面过于接近，深度缓冲区有限的精度已经不能区分哪个在前哪个在后。解决深度冲突问题普遍的方法有“对数深度”和“多边形偏移”，在Cesium当中解决该问题有两种方式“多视锥体”和“多视锥体+对数深度”。&amp;ensp; &amp;ensp; &amp;ensp; GIS-地球渲染的是行">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/nearfar.png">
<meta property="og:image" content="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/numFrust.jpg">
<meta property="og:image" content="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/depth.jpg">
<meta property="article:published_time" content="2021-08-25T06:09:28.702Z">
<meta property="article:modified_time" content="2021-08-25T06:09:28.702Z">
<meta property="article:author" content="SuperManZTF">
<meta property="article:tag" content="Cesium 3D GIS">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/nearfar.png">
  
    <link rel="alternate" href="/ThreeDimensional/atom.xml" title="SuperMan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/ThreeDimensional/css/style.css">

<meta name="generator" content="Hexo 5.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/ThreeDimensional/" id="logo">SuperMan</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/ThreeDimensional/">Home</a>
        
          <a class="main-nav-link" href="/ThreeDimensional/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/ThreeDimensional/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/SuperManZTF/ThreeDimensional"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-1-Cesium-ZFighting" class="article article-type-post" itemscope
   itemprop="blogPost">
   <div class="article-meta">
      <a href="/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/" class="article-date">
  <time datetime="2021-08-25T06:09:28.702Z" itemprop="datePublished">2021-08-25</time>
</a>
      
   </div>
   <div class="article-inner">
      
      
      <header class="article-header">
         
  
    <h1 class="article-title" itemprop="name">
      Cesium-Z-Fighting 深度冲突问题
    </h1>
  

      </header>
      
      <!-- <div class="article-entry" itemprop="articleBody">
         
         <p>&ensp; &ensp; &ensp; 在Cesium引擎中深度冲突（Z-Fighting）是绕不开的。之所以会产生深度冲突，是因为两个表面过于接近，深度缓冲区有限的精度已经不能区分哪个在前哪个在后。解决深度冲突问题普遍的方法有“对数深度”和“多边形偏移”，在Cesium当中解决该问题有两种方式“多视锥体”和“多视锥体+对数深度”。<br>&ensp; &ensp; &ensp; GIS-地球渲染的是行星级别的比例尺，用米度量的分辨率会出现深度冲突和抖动的现象。这里作者使用的是Cesium-1.71版本。关于深度冲突本质上是数值的精度问题，Cesium引擎中处理精度问题还有两种方式RTC和RTE，请结合《Cesium-Precision 精度问题》一文来理解。</p>
<h2 id="1-正常情况下Shader中深度如何计算？"><a href="#1-正常情况下Shader中深度如何计算？" class="headerlink" title="1. 正常情况下Shader中深度如何计算？"></a>1. 正常情况下Shader中深度如何计算？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// vertex shader</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    vec3 transformed = vec3( position );</span><br><span class="line">    vec4 mvPosition = vec4( transformed, 1.0 );</span><br><span class="line">    mvPosition = modelViewMatrix * mvPosition;</span><br><span class="line">    gl_Position = projectionMatrix * mvPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// fragment shader</span><br><span class="line">void <span class="function"><span class="title">mian</span></span>()&#123;</span><br><span class="line">    gl_FragColor = vec4( 1.0,0.0,0.0,1.0 ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在顶点着色器中做了两个矩阵变换（本质上是三个MV乘起来了）：modelViewMatrix和projectionMatrix，将顶点从局部坐标系转到世界坐标系转到相机坐标系转到投影坐标系，这里的projectionMatrix矩阵是根据相机的视锥体构建的（构建过程参考ThreeJS-Camera），经过矩阵计算gl_Position是被转换到投影剪裁空间（具体参考冯乐乐《Unity Shader入门精要》第四章），此处只说结论：经过矩阵变换最终写入深度缓冲区的深度值是“片元距离相机视锥体近截面的距离”（这个结论如果理解不了就先暂时接受并大胆认可它）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// program</span><br><span class="line">gl.getExtension(<span class="string">&#x27;EXT_frag_depth&#x27;</span>);</span><br><span class="line">// fragment shader</span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0); </span><br><span class="line">  gl_FragDepthEXT = 0.5; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在WebGL shader中如果想在片元着色器中修改片元的深度需要用到WebGL扩展EXT_frag_depth，使用gl_FragDepthEXT可以修改片元的深度值，后边使用对数深度修改片元深度的时候会用到这个扩展，在Cesium中这个扩展及其重要，例如贴地线/贴地面等都会涉及到深度值的修改。</p>
<h2 id="2-多边形偏移"><a href="#2-多边形偏移" class="headerlink" title="2. 多边形偏移"></a>2. 多边形偏移</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// program</span><br><span class="line">gl.enable(gl.POLYGON_OFFSET_FILL);// 启用多边形偏移</span><br><span class="line">gl.polygonOffset(1.0, 1.0);</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 开启多边形偏移之后，设置多边形偏移参数：gl.polygonOffset(factor, units), 指定加到每个顶点z值上的偏移量，偏移量按m<em>factor+r</em>units来计算，m表示顶点所在表面相对于相机视线的角度，r表示硬件能够区分两个z值之差的最小值。这种处理深度冲突的方式在深度值精度够用的情况下是可以的，但是解决不了精度不够用的情况。</p>
<h2 id="3-多视锥体渲染"><a href="#3-多视锥体渲染" class="headerlink" title="3. 多视锥体渲染"></a>3. 多视锥体渲染</h2><p>&ensp; &ensp; &ensp; 多视锥体渲染的关键是根据frameState.commandList来计算视锥体的远近截面和视锥体数量，并将frameState.commandList分类存放到view.frustumCommandsList。在Cesium-view中View.prototype.createPotentiallyVisibleSet是关键方法。<br>&ensp; &ensp; &ensp; view类中的frustumCommandsList在scene.executeCommands中会遍历并执行其中的DrawCommand，这个数组中根据视锥体数量保存着FrustumCommands（其中根据Pass保存渲染不同类型的对象的DrawCommand）。相信阅读这篇博客的同仁是熟悉Cesium渲染流程的，此处不在赘述，如果不理解请在scene.executeCommands函数中自行断点。由于该方法涉及的内容很多，这里我先贴出代码注释，接下来会把涉及到的每个点进行讲解，最后再整体总结一遍流程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">View.prototype.createPotentiallyVisibleSet = <span class="keyword">function</span> (scene) &#123;</span><br><span class="line">  var frameState = scene.frameState;</span><br><span class="line">  var camera = frameState.camera;</span><br><span class="line">  var direction = camera.directionWC;// 世界坐标下的相机方向</span><br><span class="line">  var position = camera.positionWC;// 世界坐标下的相机位置</span><br><span class="line"></span><br><span class="line">  var computeList = scene._computeCommandList;// 计算指令</span><br><span class="line">  var overlayList = scene._overlayCommandList;// 覆盖指令</span><br><span class="line">  var commandList = frameState.commandList;// 与视锥体有关的指令</span><br><span class="line"></span><br><span class="line">  // 调试“多视锥体”</span><br><span class="line">  <span class="keyword">if</span> (scene.debugShowFrustums) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 视锥体指令集合 索引置零</span><br><span class="line">  var frustumCommandsList = this.frustumCommandsList;</span><br><span class="line">  var numberOfFrustums = frustumCommandsList.length;</span><br><span class="line">  var numberOfPasses = Pass.NUMBER_OF_PASSES;</span><br><span class="line">  <span class="keyword">for</span> (var n = 0; n &lt; numberOfFrustums; ++n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var p = 0; p &lt; numberOfPasses; ++p) &#123;</span><br><span class="line">      frustumCommandsList[n].indices[p] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 通用计算指令清除</span><br><span class="line">  computeList.length = 0;</span><br><span class="line">  // 覆盖指令清除</span><br><span class="line">  overlayList.length = 0;</span><br><span class="line"></span><br><span class="line">  var commandExtents = this._commandExtents;</span><br><span class="line">  var commandExtentCapacity = commandExtents.length;</span><br><span class="line">  var commandExtentCount = 0;</span><br><span class="line"></span><br><span class="line">  // JS 数值最大值 加减 1</span><br><span class="line">  var near = +Number.MAX_VALUE;</span><br><span class="line">  var far = -Number.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  var shadowsEnabled = frameState.shadowState.shadowsEnabled;</span><br><span class="line">  var shadowNear = +Number.MAX_VALUE;</span><br><span class="line">  var shadowFar = -Number.MAX_VALUE;</span><br><span class="line">  var shadowClosestObjectSize = Number.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  // 判断地球是否遮挡物体</span><br><span class="line">  var occluder = frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;</span><br><span class="line">  // 相机视锥体</span><br><span class="line">  var cullingVolume = frameState.cullingVolume;</span><br><span class="line"></span><br><span class="line">  // get user culling volume minus the far plane.除掉视锥体远平面</span><br><span class="line">  var planes = scratchCullingVolume.planes;</span><br><span class="line">  <span class="keyword">for</span> (var k = 0; k &lt; 5; ++k) &#123;</span><br><span class="line">    planes[k] = cullingVolume.planes[k];</span><br><span class="line">  &#125;</span><br><span class="line">  cullingVolume = scratchCullingVolume;</span><br><span class="line"></span><br><span class="line">  var length = commandList.length;</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">    var <span class="built_in">command</span> = commandList[i];</span><br><span class="line">    var pass = command.pass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass === Pass.COMPUTE) &#123;// 计算指令</span><br><span class="line">      computeList.push(<span class="built_in">command</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pass === Pass.OVERLAY) &#123;// 覆盖指令</span><br><span class="line">      overlayList.push(<span class="built_in">command</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      var commandNear;</span><br><span class="line">      var commandFar;</span><br><span class="line"></span><br><span class="line">      var boundingVolume = command.boundingVolume;// 渲染指令包围盒</span><br><span class="line">      <span class="keyword">if</span> (defined(boundingVolume)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!scene.isVisible(<span class="built_in">command</span>, cullingVolume, occluder)) &#123;// 判断显示隐藏</span><br><span class="line">          <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 包围球的圆心和相机位置的射线 向 相机方向 投影 dot算出 一段距离 -&gt; 加减 半径</span><br><span class="line">        var nearFarInterval = boundingVolume.computePlaneDistances(</span><br><span class="line">          position,</span><br><span class="line">          direction,</span><br><span class="line">          scratchNearFarInterval</span><br><span class="line">        );</span><br><span class="line">        commandNear = nearFarInterval.start;</span><br><span class="line">        commandFar = nearFarInterval.stop;</span><br><span class="line"></span><br><span class="line">        // console.log(<span class="string">&#x27;near: &#x27;</span> + commandNear + <span class="string">&#x27;far: &#x27;</span> + commandFar);</span><br><span class="line"></span><br><span class="line">        near = Math.min(near, commandNear);// 根据JS最大小值限制</span><br><span class="line">        far = Math.max(far, commandFar);</span><br><span class="line"></span><br><span class="line">        // Compute a tight near and far plane <span class="keyword">for</span> commands that receive shadows. This helps compute</span><br><span class="line">        // good splits <span class="keyword">for</span> cascaded shadow maps. Ignore commands that exceed the maximum distance.</span><br><span class="line">        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes</span><br><span class="line">        // throw off the near/far fitting <span class="keyword">for</span> the shadow map. Only update <span class="keyword">for</span> globe tiles that the</span><br><span class="line">        // camera is not inside.</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          shadowsEnabled &amp;&amp;</span><br><span class="line">          command.receiveShadows &amp;&amp;</span><br><span class="line">          commandNear &lt; ShadowMap.MAXIMUM_DISTANCE &amp;&amp;</span><br><span class="line">          !(pass === Pass.GLOBE &amp;&amp; commandNear &lt; -100.0 &amp;&amp; commandFar &gt; 100.0)</span><br><span class="line">        ) &#123;</span><br><span class="line">          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.</span><br><span class="line">          var size = commandFar - commandNear;</span><br><span class="line">          <span class="keyword">if</span> (pass !== Pass.GLOBE &amp;&amp; commandNear &lt; 100.0) &#123;</span><br><span class="line">            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);</span><br><span class="line">          &#125;</span><br><span class="line">          shadowNear = Math.min(shadowNear, commandNear);</span><br><span class="line">          shadowFar = Math.max(shadowFar, commandFar);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">command</span> instanceof ClearCommand) &#123;</span><br><span class="line">        // Clear commands dont need a bounding volume - just add the clear to all frustums.</span><br><span class="line">        commandNear = camera.frustum.near;</span><br><span class="line">        commandFar = camera.frustum.far;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // If <span class="built_in">command</span> has no bounding volume we need to use the camera s</span><br><span class="line">        // worst-case near and far planes to avoid clipping something important.</span><br><span class="line">        commandNear = camera.frustum.near;</span><br><span class="line">        commandFar = camera.frustum.far;</span><br><span class="line">        near = Math.min(near, commandNear);</span><br><span class="line">        far = Math.max(far, commandFar);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var extent = commandExtents[commandExtentCount];</span><br><span class="line">      <span class="keyword">if</span> (!defined(extent)) &#123;</span><br><span class="line">        extent = commandExtents[commandExtentCount] = new CommandExtent();</span><br><span class="line">      &#125;</span><br><span class="line">      extent.command = <span class="built_in">command</span>;</span><br><span class="line">      extent.near = commandNear;</span><br><span class="line">      extent.far = commandFar;</span><br><span class="line">      commandExtentCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shadowsEnabled) &#123;</span><br><span class="line">    shadowNear = Math.min(</span><br><span class="line">      Math.max(shadowNear, camera.frustum.near),</span><br><span class="line">      camera.frustum.far</span><br><span class="line">    );</span><br><span class="line">    shadowFar = Math.max(Math.min(shadowFar, camera.frustum.far), shadowNear);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Use the computed near and far <span class="keyword">for</span> shadows</span><br><span class="line">  <span class="keyword">if</span> (shadowsEnabled) &#123;</span><br><span class="line">    frameState.shadowState.nearPlane = shadowNear;</span><br><span class="line">    frameState.shadowState.farPlane = shadowFar;</span><br><span class="line">    frameState.shadowState.closestObjectSize = shadowClosestObjectSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateFrustums(this, scene, near, far);</span><br><span class="line"></span><br><span class="line">  var c;</span><br><span class="line">  var ce;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (c = 0; c &lt; commandExtentCount; c++) &#123;</span><br><span class="line">    ce = commandExtents[c];</span><br><span class="line">    insertIntoBin(this, scene, ce.command, ce.near, ce.far);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Dereference old commands</span><br><span class="line">  <span class="keyword">if</span> (commandExtentCount &lt; commandExtentCapacity) &#123;</span><br><span class="line">    <span class="keyword">for</span> (c = commandExtentCount; c &lt; commandExtentCapacity; c++) &#123;</span><br><span class="line">      ce = commandExtents[c];</span><br><span class="line">      <span class="keyword">if</span> (!defined(ce.command)) &#123;</span><br><span class="line">        // If the <span class="built_in">command</span> is undefined, its assumed that all</span><br><span class="line">        // subsequent commmands were <span class="built_in">set</span> to undefined as well,</span><br><span class="line">        // so no need to loop over them all</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ce.command = undefined;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var numFrustums = frustumCommandsList.length;</span><br><span class="line">  var frustumSplits = frameState.frustumSplits;</span><br><span class="line">  frustumSplits.length = numFrustums + 1;</span><br><span class="line">  <span class="keyword">for</span> (var j = 0; j &lt; numFrustums; ++j) &#123;</span><br><span class="line">    frustumSplits[j] = frustumCommandsList[j].near;</span><br><span class="line">    <span class="keyword">if</span> (j === numFrustums - 1) &#123;</span><br><span class="line">      frustumSplits[j + 1] = frustumCommandsList[j].far;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 重要的事情说三遍：这个方法很重要X3！<br>&ensp; &ensp; &ensp; 首先提前说明两个事情：frameState中的occluder和cullingVolume是干什么的？<br>&ensp; &ensp; &ensp; Occluder: 由位置和半径来定义一个球Sphere再结合相机的位置，来计算一个点或者一个包围球等是否被球Sphere遮挡（具体代码详见Cesium-Occluder类），结果有三种。这里在frameState上的occluder是使用地球和相机共同定义的，用于判断某个物体（使用其包围球计算）与地球的遮挡情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var Visibility = &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Represents that no part of an object is visible.</span><br><span class="line">   */</span><br><span class="line">  NONE: -1,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that part, but not all, of an object is visible</span><br><span class="line">   */</span><br><span class="line">  PARTIAL: 0,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is visible <span class="keyword">in</span> its entirety.</span><br><span class="line">   */</span><br><span class="line">  FULL: 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; CullingVolume：由若干个面定义的体用于计算剔除。每个面是一个Cartesian4对象，xyz代表平面法线，w代表平面与原点的距离，这与ThreeJS当中Plane的定义是一样的。这里在frameState上的cullingVolume是由相机计算而来的（是视锥体，但用法有故事）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The culling volume defined by planes. </span><br><span class="line"> *</span><br><span class="line"> * @<span class="built_in">alias</span> CullingVolume</span><br><span class="line"> * @constructor</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Cartesian4[]&#125; [planes] An array of clipping planes.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> CullingVolume(planes) &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Each plane is represented by a Cartesian4 object, <span class="built_in">where</span> the x, y, and z components</span><br><span class="line">   * define the unit vector normal to the plane, and the w component is the distance of the</span><br><span class="line">   * plane from the origin.</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Cartesian4[]&#125;</span><br><span class="line">   * @default []</span><br><span class="line">   */</span><br><span class="line">  this.planes = defaultValue(planes, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在DrawCommand中会有boundingVolume（包围球），scene.isVisible(command, cullingVolume, occluder)会计算判断一个DrawCommand是否可以在此帧渲染，这个判断至关重要！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scene.prototype.isVisible = <span class="keyword">function</span> (<span class="built_in">command</span>, cullingVolume, occluder) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    defined(<span class="built_in">command</span>) &amp;&amp;</span><br><span class="line">    (!defined(command.boundingVolume) || !command.cull ||</span><br><span class="line">      (cullingVolume.computeVisibility(command.boundingVolume) !==</span><br><span class="line">        Intersect.OUTSIDE &amp;&amp;</span><br><span class="line">        (!defined(occluder) ||</span><br><span class="line">          !command.occlude ||</span><br><span class="line">          !command.boundingVolume.isOccluded(occluder))))</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在上面代码中有两个计算函数：cullingVolume.computeVisibility和command.boundingVolume.isOccluded，在上面已经讲过cullingVolume和occluder的定义以及用途，此处不再赘述。此处得出一个重要结论：(!scene.isVisible(command, cullingVolume, occluder))为false，DrawCommand就是可以渲染的! 这里需要说明一下，cullingVolume.computeVisibility的计算结果有三种情况，如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var Intersect = &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is not contained within the frustum.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  OUTSIDE: -1,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object intersects one of the frustum s planes.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  INTERSECTING: 0,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is fully within the frustum.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  INSIDE: 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 如果一个DrawCommand是可以渲染的，接下来它就将参与计算相机的远近截面。这个地方的远近截面是所有可渲染的DrawCommand计算出的commandNear和commandFar的累计，累计规则：选出near的最小值和far的最大值。每个DrawCommand是如何计算出commandNear和commandFar呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BoundingSphere.computePlaneDistances = <span class="keyword">function</span> (</span><br><span class="line">  sphere,</span><br><span class="line">  position,</span><br><span class="line">  direction,</span><br><span class="line">  result</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!defined(result)) &#123;</span><br><span class="line">    result = new Interval();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var toCenter = Cartesian3.subtract(</span><br><span class="line">    sphere.center,</span><br><span class="line">    position,</span><br><span class="line">    scratchCartesian3</span><br><span class="line">  );</span><br><span class="line">  var mag = Cartesian3.dot(direction, toCenter);</span><br><span class="line"></span><br><span class="line">  result.start = mag - sphere.radius;</span><br><span class="line">  result.stop = mag + sphere.radius;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 上面函数中有四个参数：sphere（DrawCommand包围球）position（相机世界坐标位置）direction（相机世界坐标朝向）result（返回结果），注意这里调用这个方法计算传入的参数含义只是在当前计算环境下传参意义，如果此函数用作他用另当别论。渲染指令的包围球由center和radius定义，即包围球位置和半径；通过center和position构建一条向量N，N向direction做投影P（点积计算），投影P在direction方向上的投影“覆盖”距离加上radius就是commandFar，减去radius就是commandNear，如图示。<br><img src="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/nearfar.png" alt="计算Command的near/far"><br>&ensp; &ensp; &ensp; 已经计算出了每个可渲染的DrawCommand以及累计得到了near和far，接下来就要确定视锥体的数量updateFrustums；由下面代码可以看出，根据near和far计算视锥体数量就靠一个公式：numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio))，这个公式将其输入到Graph中看一下函数图像，视锥体数量分为三个：1到1000米、1000到100万、100万到100亿之间，如图示。有了视锥体数量之后就可以创建FrustumCommands并放到view.frustumCommandsList中，上文已经说过了，view.frustumCommandsList在scene.executeCommands中遍历执行。<br><img src="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/numFrust.jpg" alt="计算视锥体数量"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateFrustums(view, scene, near, far) &#123;</span><br><span class="line">  var frameState = scene.frameState;</span><br><span class="line">  var camera = frameState.camera;</span><br><span class="line">  var farToNearRatio = frameState.useLogDepth</span><br><span class="line">    ? scene.logarithmicDepthFarToNearRatio</span><br><span class="line">    : scene.farToNearRatio;</span><br><span class="line">  var is2D = scene.mode === SceneMode.SCENE2D;</span><br><span class="line">  var nearToFarDistance2D = scene.nearToFarDistance2D;</span><br><span class="line"></span><br><span class="line">  // The computed near plane must be between the user defined near and far planes.</span><br><span class="line">  // The computed far plane must between the user defined far and computed near.</span><br><span class="line">  // This will handle the <span class="keyword">case</span> <span class="built_in">where</span> the computed near plane is further than the user defined far plane.</span><br><span class="line">  near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);</span><br><span class="line">  far = Math.max(Math.min(far, camera.frustum.far), near);</span><br><span class="line"></span><br><span class="line">  var numFrustums;</span><br><span class="line">  <span class="keyword">if</span> (is2D) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // The multifrustum <span class="keyword">for</span> 3D/CV is non-uniformly distributed.</span><br><span class="line">    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var frustumCommandsList = view.frustumCommandsList;</span><br><span class="line">  frustumCommandsList.length = numFrustums;</span><br><span class="line">  <span class="keyword">for</span> (var m = 0; m &lt; numFrustums; ++m) &#123;</span><br><span class="line">    var curNear;</span><br><span class="line">    var curFar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is2D) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);</span><br><span class="line">      curFar = Math.min(far, farToNearRatio * curNear);</span><br><span class="line">    &#125;</span><br><span class="line">    var frustumCommands = frustumCommandsList[m];</span><br><span class="line">    <span class="keyword">if</span> (!defined(frustumCommands)) &#123;</span><br><span class="line">      frustumCommands = frustumCommandsList[m] = new FrustumCommands(</span><br><span class="line">        curNear,</span><br><span class="line">        curFar</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      frustumCommands.near = curNear;</span><br><span class="line">      frustumCommands.far = curFar;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在View.prototype.createPotentiallyVisibleSet方法中有必要说一下_commandExtents这个数组，其实很简单就是在DrawCommand真正加入到view.frustumCommandsList中之前临时存放的数组，数组中的每个CommandExtent存放了DrawCommand和DrawCommand的near/far（准确说是commandNear/commandFar），根据视锥体数量来将_commandExtents数组中的DrawCommand分别添加到view.frustumCommandsList的不同视锥体指令数组之中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">CommandExtent</span></span>() &#123;</span><br><span class="line">  this.command = undefined;</span><br><span class="line">  this.near = undefined;</span><br><span class="line">  this.far = undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 至此，View.prototype.createPotentiallyVisibleSet方法中计算视锥体数量和相机远近截面的重要点都已经介绍了，接下来整体的讲一遍流程（一定要去打个断点再结合本文来理解）：</p>
<ol>
<li>获取frameState.commandList（在这一帧渲染之前所有的DrawCommand都将存在这个数组）；scene._computeCommandList和scene._overlayCommandList中分别用来存放通用GPU计算的Command（以后再讨论这个东西）和覆盖物的Command。</li>
<li>获取cullingVolume和occluder，对cullingVolume进行操作，总起来一句话：视锥体由六个面构成，去掉远截面。</li>
<li>遍历frameState.commandList数组，根据command.pass来区分是什么类型的渲染指令，pass === Pass.COMPUTE就将command添加到scene._computeCommandList中，pass === Pass.OVERLAY就将command添加到scene._overlayCommandList，这两个类型比较特殊。其他的command都将进行if/else判断：有无boundingVolume（包围球）—&gt;是否是ClearCommand清除指令—&gt;以及其他：</li>
</ol>
<hr>
<p>有无boundingVolume（包围球）：执行这个条件的代码是最复杂的；首先根据boundingVolume/cullingVolume/occluder对进行command进行选择，scene.isVisible在上文已经讲过了，被留下来的都是可渲染的command，根据包围球和相机位置方向计算commandNear/commandFar，参与near/far累计，然后被添加进commandExtents数组中。<br>是否是ClearCommand清除指令：清除指令则直接将command和相机的near/far添加进commandExtents数组中，不参与near/far累计。<br>以及其他：执行这个条件的代码是参与near/far累计操作的，它的累计是使用的相机near/far，然后添加进commandExtents数组中。</p>
<hr>
<p>4.累计完near/far，并将所有符合条件的command添加到commandExtents之后，就将进行视锥体个数的计算updateFrustums，创建对应的FrustumCommands并存在view.frustumCommandsList之中。<br>5.遍历commandExtents数组将其中的command分别存储到不同的视锥体中FrustumCommands，注意：如果一个command被两个视锥体同时占有，则需要分别加入到两个视锥体指令之中，此处也是多视锥体渲染解决深度问题的性能问题所在，因为跨视锥体的command需要渲染两次。<br>6.最后将commandExtents数组进行清除操作，将所有视锥体的远近截面值存储到frameState.frustumSplits数组中（主要用于调试用）；提示：看这部分源码会注意到，代码中有关于shadow的near/far相关计算，因为阴影的生成也是与相机相关的，near/far是必须的，这里就不讨论了。<br>&ensp; &ensp; &ensp; 总结：文首说过“多视椎体渲染”是为了解决深度冲突的问题；Cesium通过所有的的DrawCommand累计出相机最终的near和far，并通过一个公式确定在这一帧需要多少个视椎体进行渲染，然后将command分别存储在不同视椎体中，上面我们提到过一个结论：经过矩阵变换最终写入深度缓冲区的深度值是“片元距离相机视锥体近截面的距离”；也就是说相机的near越接近command，command的片元深度值就越小；所以累计计算near和far以及视椎体数量都是为了使command离相机的near面更近，深度值精度更高！如果有多个视椎体的话，cesium会遍历所有视椎体（最多三个），从后往前渲染，最远处的视椎体渲染完之后，清除深度，再使用下一个视椎体渲染，渲染完清除深度以此类推。</p>
<h2 id="4-对数深度"><a href="#4-对数深度" class="headerlink" title="4. 对数深度"></a>4. 对数深度</h2><p><img src="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/depth.jpg" alt="曲线比较"><br>&ensp; &ensp; &ensp; 在第一小节中提到了WebGL扩展EXT_frag_depth，Cesium中的对数深度需要这个扩展（其他基于WebGL的引擎的对数深度实现都需要），因为在片元着色器中需要使用gl_FragDepthEXT来修改即将写入ZBuffer中的深度值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 顶点着色器</span><br><span class="line"></span><br><span class="line">varying <span class="built_in">float</span> v_depthFromNearPlusOne;</span><br><span class="line">uniform vec2 czm_currentFrustum;// vec2(near,far)</span><br><span class="line">vec4 czm_updatePositionDepth(vec4 coords) &#123;</span><br><span class="line">   coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;</span><br><span class="line">   <span class="built_in">return</span> coords;</span><br><span class="line">&#125;</span><br><span class="line">void czm_vertexLogDepth()</span><br><span class="line">&#123;</span><br><span class="line">   v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;</span><br><span class="line">   gl_Position = czm_updatePositionDepth(gl_Position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 片元着色器</span><br><span class="line"></span><br><span class="line">varying <span class="built_in">float</span> v_depthFromNearPlusOne;</span><br><span class="line">uniform <span class="built_in">float</span> czm_farDepthFromNearPlusOne;// far -near + 1.0</span><br><span class="line">uniform <span class="built_in">float</span> czm_oneOverLog2FarDepthFromNearPlusOne;</span><br><span class="line"></span><br><span class="line">void czm_writeLogDepth(<span class="built_in">float</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (depth &lt;= 0.9999999 || depth &gt; czm_farDepthFromNearPlusOne) &#123;</span><br><span class="line">      discard;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">czm_writeLogDepth</span></span>() &#123;</span><br><span class="line">   czm_writeLogDepth(v_depthFromNearPlusOne);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp; &ensp; &ensp;上面代码是顶点着色器和片元着色器与对数深度相关的代码，在Cesium-Shader中这块代码还有其他处理，为了方便理解我做过精简。这里我要做一个说明：在上一节中我们计算过多视椎体，在使用对数深度开启时（scene.logarithmicDepthBuffer = true）,多视椎体的计算还是需要的，只不过参与计算的系数farToNearRatio不同(numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio)))。通过logarithmicDepthFarToNearRatio参与计算之后视椎体数量会减少，上面有张图可以说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * The far-to-near ratio of the multi-frustum when using a normal depth buffer.</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * This value is used to create the near and far values <span class="keyword">for</span> each frustum of the multi-frustum. It is only used</span><br><span class="line">   * when &#123;@link Scene<span class="comment">#logarithmicDepthBuffer&#125; is &lt;code&gt;false&lt;/code&gt;. When &lt;code&gt;logarithmicDepthBuffer&lt;/code&gt; is</span></span><br><span class="line">   * &lt;code&gt;<span class="literal">true</span>&lt;/code&gt;, use &#123;@link Scene<span class="comment">#logarithmicDepthFarToNearRatio&#125;.</span></span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @default 1000.0</span><br><span class="line">   */</span><br><span class="line">this.farToNearRatio = 1000.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * This value is used to create the near and far values <span class="keyword">for</span> each frustum of the multi-frustum. It is only used</span><br><span class="line">   * when &#123;@link Scene<span class="comment">#logarithmicDepthBuffer&#125; is &lt;code&gt;true&lt;/code&gt;. When &lt;code&gt;logarithmicDepthBuffer&lt;/code&gt; is</span></span><br><span class="line">   * &lt;code&gt;<span class="literal">false</span>&lt;/code&gt;, use &#123;@link Scene<span class="comment">#farToNearRatio&#125;.</span></span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @default 1e9</span><br><span class="line">   */</span><br><span class="line">this.logarithmicDepthFarToNearRatio = 1e9;</span><br></pre></td></tr></table></figure>
<p>&ensp; &ensp; &ensp;对数深度的处理核心就是着色器当中的重新计算片元深度的代码，大家可以把深度计算公式在Graph中看一眼函数图像，一切都明白了！depth值越大，经过log之后曲线增长越缓，这说明什么？这说明片元离相机近截面越远，经过log算出来的depth值会比线性计算出来的值要小很多，值小，精度就够了！</p>
<blockquote><p>文章中有任何错误，请批评勘正</p>
<footer><strong>@superman 1780721345@qq.com</strong></footer></blockquote>


         
      </div> -->
      <div class="article-entry" itemprop="articleBody">
         
         
         
         <p>&ensp; &ensp; &ensp; 在Cesium引擎中深度冲突（Z-Fighting）是绕不开的。之所以会产生深度冲突，是因为两个表面过于接近，深度缓冲区有限的精度已经不能区分哪个在前哪个在后。解决深度冲突问题普遍的方法有“对数深度”和“多边形偏移”，在Cesium当中解决该问题有两种方式“多视锥体”和“多视锥体+对数深度”。<br>&ensp; &ensp; &ensp; GIS-地球渲染的是行星级别的比例尺，用米度量的分辨率会出现深度冲突和抖动的现象。这里作者使用的是Cesium-1.71版本。关于深度冲突本质上是数值的精度问题，Cesium引擎中处理精度问题还有两种方式RTC和RTE，请结合《Cesium-Precision 精度问题》一文来理解。</p>
<h2 id="1-正常情况下Shader中深度如何计算？"><a href="#1-正常情况下Shader中深度如何计算？" class="headerlink" title="1. 正常情况下Shader中深度如何计算？"></a>1. 正常情况下Shader中深度如何计算？</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// vertex shader</span><br><span class="line">void <span class="function"><span class="title">main</span></span>()&#123;</span><br><span class="line">    vec3 transformed = vec3( position );</span><br><span class="line">    vec4 mvPosition = vec4( transformed, 1.0 );</span><br><span class="line">    mvPosition = modelViewMatrix * mvPosition;</span><br><span class="line">    gl_Position = projectionMatrix * mvPosition;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// fragment shader</span><br><span class="line">void <span class="function"><span class="title">mian</span></span>()&#123;</span><br><span class="line">    gl_FragColor = vec4( 1.0,0.0,0.0,1.0 ); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在顶点着色器中做了两个矩阵变换（本质上是三个MV乘起来了）：modelViewMatrix和projectionMatrix，将顶点从局部坐标系转到世界坐标系转到相机坐标系转到投影坐标系，这里的projectionMatrix矩阵是根据相机的视锥体构建的（构建过程参考ThreeJS-Camera），经过矩阵计算gl_Position是被转换到投影剪裁空间（具体参考冯乐乐《Unity Shader入门精要》第四章），此处只说结论：经过矩阵变换最终写入深度缓冲区的深度值是“片元距离相机视锥体近截面的距离”（这个结论如果理解不了就先暂时接受并大胆认可它）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// program</span><br><span class="line">gl.getExtension(<span class="string">&#x27;EXT_frag_depth&#x27;</span>);</span><br><span class="line">// fragment shader</span><br><span class="line">void <span class="function"><span class="title">main</span></span>() &#123;</span><br><span class="line">  gl_FragColor = vec4(1.0, 0.0, 1.0, 1.0); </span><br><span class="line">  gl_FragDepthEXT = 0.5; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在WebGL shader中如果想在片元着色器中修改片元的深度需要用到WebGL扩展EXT_frag_depth，使用gl_FragDepthEXT可以修改片元的深度值，后边使用对数深度修改片元深度的时候会用到这个扩展，在Cesium中这个扩展及其重要，例如贴地线/贴地面等都会涉及到深度值的修改。</p>
<h2 id="2-多边形偏移"><a href="#2-多边形偏移" class="headerlink" title="2. 多边形偏移"></a>2. 多边形偏移</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// program</span><br><span class="line">gl.enable(gl.POLYGON_OFFSET_FILL);// 启用多边形偏移</span><br><span class="line">gl.polygonOffset(1.0, 1.0);</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 开启多边形偏移之后，设置多边形偏移参数：gl.polygonOffset(factor, units), 指定加到每个顶点z值上的偏移量，偏移量按m<em>factor+r</em>units来计算，m表示顶点所在表面相对于相机视线的角度，r表示硬件能够区分两个z值之差的最小值。这种处理深度冲突的方式在深度值精度够用的情况下是可以的，但是解决不了精度不够用的情况。</p>
<h2 id="3-多视锥体渲染"><a href="#3-多视锥体渲染" class="headerlink" title="3. 多视锥体渲染"></a>3. 多视锥体渲染</h2><p>&ensp; &ensp; &ensp; 多视锥体渲染的关键是根据frameState.commandList来计算视锥体的远近截面和视锥体数量，并将frameState.commandList分类存放到view.frustumCommandsList。在Cesium-view中View.prototype.createPotentiallyVisibleSet是关键方法。<br>&ensp; &ensp; &ensp; view类中的frustumCommandsList在scene.executeCommands中会遍历并执行其中的DrawCommand，这个数组中根据视锥体数量保存着FrustumCommands（其中根据Pass保存渲染不同类型的对象的DrawCommand）。相信阅读这篇博客的同仁是熟悉Cesium渲染流程的，此处不在赘述，如果不理解请在scene.executeCommands函数中自行断点。由于该方法涉及的内容很多，这里我先贴出代码注释，接下来会把涉及到的每个点进行讲解，最后再整体总结一遍流程。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br></pre></td><td class="code"><pre><span class="line">View.prototype.createPotentiallyVisibleSet = <span class="keyword">function</span> (scene) &#123;</span><br><span class="line">  var frameState = scene.frameState;</span><br><span class="line">  var camera = frameState.camera;</span><br><span class="line">  var direction = camera.directionWC;// 世界坐标下的相机方向</span><br><span class="line">  var position = camera.positionWC;// 世界坐标下的相机位置</span><br><span class="line"></span><br><span class="line">  var computeList = scene._computeCommandList;// 计算指令</span><br><span class="line">  var overlayList = scene._overlayCommandList;// 覆盖指令</span><br><span class="line">  var commandList = frameState.commandList;// 与视锥体有关的指令</span><br><span class="line"></span><br><span class="line">  // 调试“多视锥体”</span><br><span class="line">  <span class="keyword">if</span> (scene.debugShowFrustums) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 视锥体指令集合 索引置零</span><br><span class="line">  var frustumCommandsList = this.frustumCommandsList;</span><br><span class="line">  var numberOfFrustums = frustumCommandsList.length;</span><br><span class="line">  var numberOfPasses = Pass.NUMBER_OF_PASSES;</span><br><span class="line">  <span class="keyword">for</span> (var n = 0; n &lt; numberOfFrustums; ++n) &#123;</span><br><span class="line">    <span class="keyword">for</span> (var p = 0; p &lt; numberOfPasses; ++p) &#123;</span><br><span class="line">      frustumCommandsList[n].indices[p] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // 通用计算指令清除</span><br><span class="line">  computeList.length = 0;</span><br><span class="line">  // 覆盖指令清除</span><br><span class="line">  overlayList.length = 0;</span><br><span class="line"></span><br><span class="line">  var commandExtents = this._commandExtents;</span><br><span class="line">  var commandExtentCapacity = commandExtents.length;</span><br><span class="line">  var commandExtentCount = 0;</span><br><span class="line"></span><br><span class="line">  // JS 数值最大值 加减 1</span><br><span class="line">  var near = +Number.MAX_VALUE;</span><br><span class="line">  var far = -Number.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  var shadowsEnabled = frameState.shadowState.shadowsEnabled;</span><br><span class="line">  var shadowNear = +Number.MAX_VALUE;</span><br><span class="line">  var shadowFar = -Number.MAX_VALUE;</span><br><span class="line">  var shadowClosestObjectSize = Number.MAX_VALUE;</span><br><span class="line"></span><br><span class="line">  // 判断地球是否遮挡物体</span><br><span class="line">  var occluder = frameState.mode === SceneMode.SCENE3D ? frameState.occluder : undefined;</span><br><span class="line">  // 相机视锥体</span><br><span class="line">  var cullingVolume = frameState.cullingVolume;</span><br><span class="line"></span><br><span class="line">  // get user culling volume minus the far plane.除掉视锥体远平面</span><br><span class="line">  var planes = scratchCullingVolume.planes;</span><br><span class="line">  <span class="keyword">for</span> (var k = 0; k &lt; 5; ++k) &#123;</span><br><span class="line">    planes[k] = cullingVolume.planes[k];</span><br><span class="line">  &#125;</span><br><span class="line">  cullingVolume = scratchCullingVolume;</span><br><span class="line"></span><br><span class="line">  var length = commandList.length;</span><br><span class="line">  <span class="keyword">for</span> (var i = 0; i &lt; length; ++i) &#123;</span><br><span class="line">    var <span class="built_in">command</span> = commandList[i];</span><br><span class="line">    var pass = command.pass;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pass === Pass.COMPUTE) &#123;// 计算指令</span><br><span class="line">      computeList.push(<span class="built_in">command</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pass === Pass.OVERLAY) &#123;// 覆盖指令</span><br><span class="line">      overlayList.push(<span class="built_in">command</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      var commandNear;</span><br><span class="line">      var commandFar;</span><br><span class="line"></span><br><span class="line">      var boundingVolume = command.boundingVolume;// 渲染指令包围盒</span><br><span class="line">      <span class="keyword">if</span> (defined(boundingVolume)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!scene.isVisible(<span class="built_in">command</span>, cullingVolume, occluder)) &#123;// 判断显示隐藏</span><br><span class="line">          <span class="built_in">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 包围球的圆心和相机位置的射线 向 相机方向 投影 dot算出 一段距离 -&gt; 加减 半径</span><br><span class="line">        var nearFarInterval = boundingVolume.computePlaneDistances(</span><br><span class="line">          position,</span><br><span class="line">          direction,</span><br><span class="line">          scratchNearFarInterval</span><br><span class="line">        );</span><br><span class="line">        commandNear = nearFarInterval.start;</span><br><span class="line">        commandFar = nearFarInterval.stop;</span><br><span class="line"></span><br><span class="line">        // console.log(<span class="string">&#x27;near: &#x27;</span> + commandNear + <span class="string">&#x27;far: &#x27;</span> + commandFar);</span><br><span class="line"></span><br><span class="line">        near = Math.min(near, commandNear);// 根据JS最大小值限制</span><br><span class="line">        far = Math.max(far, commandFar);</span><br><span class="line"></span><br><span class="line">        // Compute a tight near and far plane <span class="keyword">for</span> commands that receive shadows. This helps compute</span><br><span class="line">        // good splits <span class="keyword">for</span> cascaded shadow maps. Ignore commands that exceed the maximum distance.</span><br><span class="line">        // When moving the camera low LOD globe tiles begin to load, whose bounding volumes</span><br><span class="line">        // throw off the near/far fitting <span class="keyword">for</span> the shadow map. Only update <span class="keyword">for</span> globe tiles that the</span><br><span class="line">        // camera is not inside.</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          shadowsEnabled &amp;&amp;</span><br><span class="line">          command.receiveShadows &amp;&amp;</span><br><span class="line">          commandNear &lt; ShadowMap.MAXIMUM_DISTANCE &amp;&amp;</span><br><span class="line">          !(pass === Pass.GLOBE &amp;&amp; commandNear &lt; -100.0 &amp;&amp; commandFar &gt; 100.0)</span><br><span class="line">        ) &#123;</span><br><span class="line">          // Get the smallest bounding volume the camera is near. This is used to place more shadow detail near the object.</span><br><span class="line">          var size = commandFar - commandNear;</span><br><span class="line">          <span class="keyword">if</span> (pass !== Pass.GLOBE &amp;&amp; commandNear &lt; 100.0) &#123;</span><br><span class="line">            shadowClosestObjectSize = Math.min(shadowClosestObjectSize, size);</span><br><span class="line">          &#125;</span><br><span class="line">          shadowNear = Math.min(shadowNear, commandNear);</span><br><span class="line">          shadowFar = Math.max(shadowFar, commandFar);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">command</span> instanceof ClearCommand) &#123;</span><br><span class="line">        // Clear commands dont need a bounding volume - just add the clear to all frustums.</span><br><span class="line">        commandNear = camera.frustum.near;</span><br><span class="line">        commandFar = camera.frustum.far;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        // If <span class="built_in">command</span> has no bounding volume we need to use the camera s</span><br><span class="line">        // worst-case near and far planes to avoid clipping something important.</span><br><span class="line">        commandNear = camera.frustum.near;</span><br><span class="line">        commandFar = camera.frustum.far;</span><br><span class="line">        near = Math.min(near, commandNear);</span><br><span class="line">        far = Math.max(far, commandFar);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      var extent = commandExtents[commandExtentCount];</span><br><span class="line">      <span class="keyword">if</span> (!defined(extent)) &#123;</span><br><span class="line">        extent = commandExtents[commandExtentCount] = new CommandExtent();</span><br><span class="line">      &#125;</span><br><span class="line">      extent.command = <span class="built_in">command</span>;</span><br><span class="line">      extent.near = commandNear;</span><br><span class="line">      extent.far = commandFar;</span><br><span class="line">      commandExtentCount++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shadowsEnabled) &#123;</span><br><span class="line">    shadowNear = Math.min(</span><br><span class="line">      Math.max(shadowNear, camera.frustum.near),</span><br><span class="line">      camera.frustum.far</span><br><span class="line">    );</span><br><span class="line">    shadowFar = Math.max(Math.min(shadowFar, camera.frustum.far), shadowNear);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Use the computed near and far <span class="keyword">for</span> shadows</span><br><span class="line">  <span class="keyword">if</span> (shadowsEnabled) &#123;</span><br><span class="line">    frameState.shadowState.nearPlane = shadowNear;</span><br><span class="line">    frameState.shadowState.farPlane = shadowFar;</span><br><span class="line">    frameState.shadowState.closestObjectSize = shadowClosestObjectSize;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  updateFrustums(this, scene, near, far);</span><br><span class="line"></span><br><span class="line">  var c;</span><br><span class="line">  var ce;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (c = 0; c &lt; commandExtentCount; c++) &#123;</span><br><span class="line">    ce = commandExtents[c];</span><br><span class="line">    insertIntoBin(this, scene, ce.command, ce.near, ce.far);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  // Dereference old commands</span><br><span class="line">  <span class="keyword">if</span> (commandExtentCount &lt; commandExtentCapacity) &#123;</span><br><span class="line">    <span class="keyword">for</span> (c = commandExtentCount; c &lt; commandExtentCapacity; c++) &#123;</span><br><span class="line">      ce = commandExtents[c];</span><br><span class="line">      <span class="keyword">if</span> (!defined(ce.command)) &#123;</span><br><span class="line">        // If the <span class="built_in">command</span> is undefined, its assumed that all</span><br><span class="line">        // subsequent commmands were <span class="built_in">set</span> to undefined as well,</span><br><span class="line">        // so no need to loop over them all</span><br><span class="line">        <span class="built_in">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      ce.command = undefined;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var numFrustums = frustumCommandsList.length;</span><br><span class="line">  var frustumSplits = frameState.frustumSplits;</span><br><span class="line">  frustumSplits.length = numFrustums + 1;</span><br><span class="line">  <span class="keyword">for</span> (var j = 0; j &lt; numFrustums; ++j) &#123;</span><br><span class="line">    frustumSplits[j] = frustumCommandsList[j].near;</span><br><span class="line">    <span class="keyword">if</span> (j === numFrustums - 1) &#123;</span><br><span class="line">      frustumSplits[j + 1] = frustumCommandsList[j].far;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 重要的事情说三遍：这个方法很重要X3！<br>&ensp; &ensp; &ensp; 首先提前说明两个事情：frameState中的occluder和cullingVolume是干什么的？<br>&ensp; &ensp; &ensp; Occluder: 由位置和半径来定义一个球Sphere再结合相机的位置，来计算一个点或者一个包围球等是否被球Sphere遮挡（具体代码详见Cesium-Occluder类），结果有三种。这里在frameState上的occluder是使用地球和相机共同定义的，用于判断某个物体（使用其包围球计算）与地球的遮挡情况。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var Visibility = &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Represents that no part of an object is visible.</span><br><span class="line">   */</span><br><span class="line">  NONE: -1,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that part, but not all, of an object is visible</span><br><span class="line">   */</span><br><span class="line">  PARTIAL: 0,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is visible <span class="keyword">in</span> its entirety.</span><br><span class="line">   */</span><br><span class="line">  FULL: 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; CullingVolume：由若干个面定义的体用于计算剔除。每个面是一个Cartesian4对象，xyz代表平面法线，w代表平面与原点的距离，这与ThreeJS当中Plane的定义是一样的。这里在frameState上的cullingVolume是由相机计算而来的（是视锥体，但用法有故事）。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * The culling volume defined by planes. </span><br><span class="line"> *</span><br><span class="line"> * @<span class="built_in">alias</span> CullingVolume</span><br><span class="line"> * @constructor</span><br><span class="line"> *</span><br><span class="line"> * @param &#123;Cartesian4[]&#125; [planes] An array of clipping planes.</span><br><span class="line"> */</span><br><span class="line"><span class="keyword">function</span> CullingVolume(planes) &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Each plane is represented by a Cartesian4 object, <span class="built_in">where</span> the x, y, and z components</span><br><span class="line">   * define the unit vector normal to the plane, and the w component is the distance of the</span><br><span class="line">   * plane from the origin.</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Cartesian4[]&#125;</span><br><span class="line">   * @default []</span><br><span class="line">   */</span><br><span class="line">  this.planes = defaultValue(planes, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在DrawCommand中会有boundingVolume（包围球），scene.isVisible(command, cullingVolume, occluder)会计算判断一个DrawCommand是否可以在此帧渲染，这个判断至关重要！</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Scene.prototype.isVisible = <span class="keyword">function</span> (<span class="built_in">command</span>, cullingVolume, occluder) &#123;</span><br><span class="line">  <span class="built_in">return</span> (</span><br><span class="line">    defined(<span class="built_in">command</span>) &amp;&amp;</span><br><span class="line">    (!defined(command.boundingVolume) || !command.cull ||</span><br><span class="line">      (cullingVolume.computeVisibility(command.boundingVolume) !==</span><br><span class="line">        Intersect.OUTSIDE &amp;&amp;</span><br><span class="line">        (!defined(occluder) ||</span><br><span class="line">          !command.occlude ||</span><br><span class="line">          !command.boundingVolume.isOccluded(occluder))))</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在上面代码中有两个计算函数：cullingVolume.computeVisibility和command.boundingVolume.isOccluded，在上面已经讲过cullingVolume和occluder的定义以及用途，此处不再赘述。此处得出一个重要结论：(!scene.isVisible(command, cullingVolume, occluder))为false，DrawCommand就是可以渲染的! 这里需要说明一下，cullingVolume.computeVisibility的计算结果有三种情况，如下代码：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var Intersect = &#123;</span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is not contained within the frustum.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  OUTSIDE: -1,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object intersects one of the frustum s planes.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  INTERSECTING: 0,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Represents that an object is fully within the frustum.</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @constant</span><br><span class="line">   */</span><br><span class="line">  INSIDE: 1,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 如果一个DrawCommand是可以渲染的，接下来它就将参与计算相机的远近截面。这个地方的远近截面是所有可渲染的DrawCommand计算出的commandNear和commandFar的累计，累计规则：选出near的最小值和far的最大值。每个DrawCommand是如何计算出commandNear和commandFar呢？</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">BoundingSphere.computePlaneDistances = <span class="keyword">function</span> (</span><br><span class="line">  sphere,</span><br><span class="line">  position,</span><br><span class="line">  direction,</span><br><span class="line">  result</span><br><span class="line">) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!defined(result)) &#123;</span><br><span class="line">    result = new Interval();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var toCenter = Cartesian3.subtract(</span><br><span class="line">    sphere.center,</span><br><span class="line">    position,</span><br><span class="line">    scratchCartesian3</span><br><span class="line">  );</span><br><span class="line">  var mag = Cartesian3.dot(direction, toCenter);</span><br><span class="line"></span><br><span class="line">  result.start = mag - sphere.radius;</span><br><span class="line">  result.stop = mag + sphere.radius;</span><br><span class="line">  <span class="built_in">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 上面函数中有四个参数：sphere（DrawCommand包围球）position（相机世界坐标位置）direction（相机世界坐标朝向）result（返回结果），注意这里调用这个方法计算传入的参数含义只是在当前计算环境下传参意义，如果此函数用作他用另当别论。渲染指令的包围球由center和radius定义，即包围球位置和半径；通过center和position构建一条向量N，N向direction做投影P（点积计算），投影P在direction方向上的投影“覆盖”距离加上radius就是commandFar，减去radius就是commandNear，如图示。<br><img src="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/nearfar.png" alt="计算Command的near/far"><br>&ensp; &ensp; &ensp; 已经计算出了每个可渲染的DrawCommand以及累计得到了near和far，接下来就要确定视锥体的数量updateFrustums；由下面代码可以看出，根据near和far计算视锥体数量就靠一个公式：numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio))，这个公式将其输入到Graph中看一下函数图像，视锥体数量分为三个：1到1000米、1000到100万、100万到100亿之间，如图示。有了视锥体数量之后就可以创建FrustumCommands并放到view.frustumCommandsList中，上文已经说过了，view.frustumCommandsList在scene.executeCommands中遍历执行。<br><img src="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/numFrust.jpg" alt="计算视锥体数量"></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> updateFrustums(view, scene, near, far) &#123;</span><br><span class="line">  var frameState = scene.frameState;</span><br><span class="line">  var camera = frameState.camera;</span><br><span class="line">  var farToNearRatio = frameState.useLogDepth</span><br><span class="line">    ? scene.logarithmicDepthFarToNearRatio</span><br><span class="line">    : scene.farToNearRatio;</span><br><span class="line">  var is2D = scene.mode === SceneMode.SCENE2D;</span><br><span class="line">  var nearToFarDistance2D = scene.nearToFarDistance2D;</span><br><span class="line"></span><br><span class="line">  // The computed near plane must be between the user defined near and far planes.</span><br><span class="line">  // The computed far plane must between the user defined far and computed near.</span><br><span class="line">  // This will handle the <span class="keyword">case</span> <span class="built_in">where</span> the computed near plane is further than the user defined far plane.</span><br><span class="line">  near = Math.min(Math.max(near, camera.frustum.near), camera.frustum.far);</span><br><span class="line">  far = Math.max(Math.min(far, camera.frustum.far), near);</span><br><span class="line"></span><br><span class="line">  var numFrustums;</span><br><span class="line">  <span class="keyword">if</span> (is2D) &#123;</span><br><span class="line">    ......</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    // The multifrustum <span class="keyword">for</span> 3D/CV is non-uniformly distributed.</span><br><span class="line">    numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  var frustumCommandsList = view.frustumCommandsList;</span><br><span class="line">  frustumCommandsList.length = numFrustums;</span><br><span class="line">  <span class="keyword">for</span> (var m = 0; m &lt; numFrustums; ++m) &#123;</span><br><span class="line">    var curNear;</span><br><span class="line">    var curFar;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is2D) &#123;</span><br><span class="line">      ......</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      curNear = Math.max(near, Math.pow(farToNearRatio, m) * near);</span><br><span class="line">      curFar = Math.min(far, farToNearRatio * curNear);</span><br><span class="line">    &#125;</span><br><span class="line">    var frustumCommands = frustumCommandsList[m];</span><br><span class="line">    <span class="keyword">if</span> (!defined(frustumCommands)) &#123;</span><br><span class="line">      frustumCommands = frustumCommandsList[m] = new FrustumCommands(</span><br><span class="line">        curNear,</span><br><span class="line">        curFar</span><br><span class="line">      );</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      frustumCommands.near = curNear;</span><br><span class="line">      frustumCommands.far = curFar;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 在View.prototype.createPotentiallyVisibleSet方法中有必要说一下_commandExtents这个数组，其实很简单就是在DrawCommand真正加入到view.frustumCommandsList中之前临时存放的数组，数组中的每个CommandExtent存放了DrawCommand和DrawCommand的near/far（准确说是commandNear/commandFar），根据视锥体数量来将_commandExtents数组中的DrawCommand分别添加到view.frustumCommandsList的不同视锥体指令数组之中。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">CommandExtent</span></span>() &#123;</span><br><span class="line">  this.command = undefined;</span><br><span class="line">  this.near = undefined;</span><br><span class="line">  this.far = undefined;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&ensp; &ensp; &ensp; 至此，View.prototype.createPotentiallyVisibleSet方法中计算视锥体数量和相机远近截面的重要点都已经介绍了，接下来整体的讲一遍流程（一定要去打个断点再结合本文来理解）：</p>
<ol>
<li>获取frameState.commandList（在这一帧渲染之前所有的DrawCommand都将存在这个数组）；scene._computeCommandList和scene._overlayCommandList中分别用来存放通用GPU计算的Command（以后再讨论这个东西）和覆盖物的Command。</li>
<li>获取cullingVolume和occluder，对cullingVolume进行操作，总起来一句话：视锥体由六个面构成，去掉远截面。</li>
<li>遍历frameState.commandList数组，根据command.pass来区分是什么类型的渲染指令，pass === Pass.COMPUTE就将command添加到scene._computeCommandList中，pass === Pass.OVERLAY就将command添加到scene._overlayCommandList，这两个类型比较特殊。其他的command都将进行if/else判断：有无boundingVolume（包围球）—&gt;是否是ClearCommand清除指令—&gt;以及其他：</li>
</ol>
<hr>
<p>有无boundingVolume（包围球）：执行这个条件的代码是最复杂的；首先根据boundingVolume/cullingVolume/occluder对进行command进行选择，scene.isVisible在上文已经讲过了，被留下来的都是可渲染的command，根据包围球和相机位置方向计算commandNear/commandFar，参与near/far累计，然后被添加进commandExtents数组中。<br>是否是ClearCommand清除指令：清除指令则直接将command和相机的near/far添加进commandExtents数组中，不参与near/far累计。<br>以及其他：执行这个条件的代码是参与near/far累计操作的，它的累计是使用的相机near/far，然后添加进commandExtents数组中。</p>
<hr>
<p>4.累计完near/far，并将所有符合条件的command添加到commandExtents之后，就将进行视锥体个数的计算updateFrustums，创建对应的FrustumCommands并存在view.frustumCommandsList之中。<br>5.遍历commandExtents数组将其中的command分别存储到不同的视锥体中FrustumCommands，注意：如果一个command被两个视锥体同时占有，则需要分别加入到两个视锥体指令之中，此处也是多视锥体渲染解决深度问题的性能问题所在，因为跨视锥体的command需要渲染两次。<br>6.最后将commandExtents数组进行清除操作，将所有视锥体的远近截面值存储到frameState.frustumSplits数组中（主要用于调试用）；提示：看这部分源码会注意到，代码中有关于shadow的near/far相关计算，因为阴影的生成也是与相机相关的，near/far是必须的，这里就不讨论了。<br>&ensp; &ensp; &ensp; 总结：文首说过“多视椎体渲染”是为了解决深度冲突的问题；Cesium通过所有的的DrawCommand累计出相机最终的near和far，并通过一个公式确定在这一帧需要多少个视椎体进行渲染，然后将command分别存储在不同视椎体中，上面我们提到过一个结论：经过矩阵变换最终写入深度缓冲区的深度值是“片元距离相机视锥体近截面的距离”；也就是说相机的near越接近command，command的片元深度值就越小；所以累计计算near和far以及视椎体数量都是为了使command离相机的near面更近，深度值精度更高！如果有多个视椎体的话，cesium会遍历所有视椎体（最多三个），从后往前渲染，最远处的视椎体渲染完之后，清除深度，再使用下一个视椎体渲染，渲染完清除深度以此类推。</p>
<h2 id="4-对数深度"><a href="#4-对数深度" class="headerlink" title="4. 对数深度"></a>4. 对数深度</h2><p><img src="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/2021/08/25/1-Cesium-ZFighting/depth.jpg" alt="曲线比较"><br>&ensp; &ensp; &ensp; 在第一小节中提到了WebGL扩展EXT_frag_depth，Cesium中的对数深度需要这个扩展（其他基于WebGL的引擎的对数深度实现都需要），因为在片元着色器中需要使用gl_FragDepthEXT来修改即将写入ZBuffer中的深度值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 顶点着色器</span><br><span class="line"></span><br><span class="line">varying <span class="built_in">float</span> v_depthFromNearPlusOne;</span><br><span class="line">uniform vec2 czm_currentFrustum;// vec2(near,far)</span><br><span class="line">vec4 czm_updatePositionDepth(vec4 coords) &#123;</span><br><span class="line">   coords.z = clamp(coords.z / coords.w, -1.0, 1.0) * coords.w;</span><br><span class="line">   <span class="built_in">return</span> coords;</span><br><span class="line">&#125;</span><br><span class="line">void czm_vertexLogDepth()</span><br><span class="line">&#123;</span><br><span class="line">   v_depthFromNearPlusOne = (gl_Position.w - czm_currentFrustum.x) + 1.0;</span><br><span class="line">   gl_Position = czm_updatePositionDepth(gl_Position);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 片元着色器</span><br><span class="line"></span><br><span class="line">varying <span class="built_in">float</span> v_depthFromNearPlusOne;</span><br><span class="line">uniform <span class="built_in">float</span> czm_farDepthFromNearPlusOne;// far -near + 1.0</span><br><span class="line">uniform <span class="built_in">float</span> czm_oneOverLog2FarDepthFromNearPlusOne;</span><br><span class="line"></span><br><span class="line">void czm_writeLogDepth(<span class="built_in">float</span> depth)</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">if</span> (depth &lt;= 0.9999999 || depth &gt; czm_farDepthFromNearPlusOne) &#123;</span><br><span class="line">      discard;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   gl_FragDepthEXT = log2(depth) * czm_oneOverLog2FarDepthFromNearPlusOne;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void <span class="function"><span class="title">czm_writeLogDepth</span></span>() &#123;</span><br><span class="line">   czm_writeLogDepth(v_depthFromNearPlusOne);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&ensp; &ensp; &ensp;上面代码是顶点着色器和片元着色器与对数深度相关的代码，在Cesium-Shader中这块代码还有其他处理，为了方便理解我做过精简。这里我要做一个说明：在上一节中我们计算过多视椎体，在使用对数深度开启时（scene.logarithmicDepthBuffer = true）,多视椎体的计算还是需要的，只不过参与计算的系数farToNearRatio不同(numFrustums = Math.ceil(Math.log(far / near) / Math.log(farToNearRatio)))。通过logarithmicDepthFarToNearRatio参与计算之后视椎体数量会减少，上面有张图可以说明。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">   * The far-to-near ratio of the multi-frustum when using a normal depth buffer.</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * This value is used to create the near and far values <span class="keyword">for</span> each frustum of the multi-frustum. It is only used</span><br><span class="line">   * when &#123;@link Scene<span class="comment">#logarithmicDepthBuffer&#125; is &lt;code&gt;false&lt;/code&gt;. When &lt;code&gt;logarithmicDepthBuffer&lt;/code&gt; is</span></span><br><span class="line">   * &lt;code&gt;<span class="literal">true</span>&lt;/code&gt;, use &#123;@link Scene<span class="comment">#logarithmicDepthFarToNearRatio&#125;.</span></span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @default 1000.0</span><br><span class="line">   */</span><br><span class="line">this.farToNearRatio = 1000.0;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.</span><br><span class="line">   * &lt;p&gt;</span><br><span class="line">   * This value is used to create the near and far values <span class="keyword">for</span> each frustum of the multi-frustum. It is only used</span><br><span class="line">   * when &#123;@link Scene<span class="comment">#logarithmicDepthBuffer&#125; is &lt;code&gt;true&lt;/code&gt;. When &lt;code&gt;logarithmicDepthBuffer&lt;/code&gt; is</span></span><br><span class="line">   * &lt;code&gt;<span class="literal">false</span>&lt;/code&gt;, use &#123;@link Scene<span class="comment">#farToNearRatio&#125;.</span></span><br><span class="line">   * &lt;/p&gt;</span><br><span class="line">   *</span><br><span class="line">   * @<span class="built_in">type</span> &#123;Number&#125;</span><br><span class="line">   * @default 1e9</span><br><span class="line">   */</span><br><span class="line">this.logarithmicDepthFarToNearRatio = 1e9;</span><br></pre></td></tr></table></figure>
<p>&ensp; &ensp; &ensp;对数深度的处理核心就是着色器当中的重新计算片元深度的代码，大家可以把深度计算公式在Graph中看一眼函数图像，一切都明白了！depth值越大，经过log之后曲线增长越缓，这说明什么？这说明片元离相机近截面越远，经过log算出来的depth值会比线性计算出来的值要小很多，值小，精度就够了！</p>
<blockquote><p>文章中有任何错误，请批评勘正</p>
<footer><strong>@superman 1780721345@qq.com</strong></footer></blockquote>


         
         
      </div>
      <footer class="article-footer">
         <a data-url="https://github.com/SuperManZTF/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/" data-id="cl5bvngeb0004joqt77mkgy7u" class="article-share-link">Share</a>
         
         
      </footer>
   </div>
   
   
<nav id="article-nav">
  
  
    <a href="/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Cesium-地球瓦片遮挡计算</div>
    </a>
  
</nav>

   
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/ThreeDimensional/archives/2021/08/">August 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/ThreeDimensional/archives/2021/01/">January 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/ThreeDimensional/archives/2020/11/">November 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/ThreeDimensional/2021/08/25/1-Cesium-ZFighting/">Cesium-Z-Fighting 深度冲突问题</a>
          </li>
        
          <li>
            <a href="/ThreeDimensional/2021/01/04/5-Cesium-%E5%9C%B0%E7%90%83%E7%93%A6%E7%89%87%E9%81%AE%E6%8C%A1%E8%AE%A1%E7%AE%97/">Cesium-地球瓦片遮挡计算</a>
          </li>
        
          <li>
            <a href="/ThreeDimensional/2020/11/08/4-Cesium-DrawCommand/">Cesium-DrawCommand</a>
          </li>
        
          <li>
            <a href="/ThreeDimensional/2020/11/08/3-Cesium-Pass/">Cesium-Pass 渲染对象类型</a>
          </li>
        
          <li>
            <a href="/ThreeDimensional/2020/11/08/2-Cesium-Precision/">Cesium-Precision 精度问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2022 SuperManZTF<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/ThreeDimensional/" class="mobile-nav-link">Home</a>
  
    <a href="/ThreeDimensional/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/ThreeDimensional/fancybox/jquery.fancybox.css">

  
<script src="/ThreeDimensional/fancybox/jquery.fancybox.pack.js"></script>




<script src="/ThreeDimensional/js/script.js"></script>




  </div>
</body>
</html>